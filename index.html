<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=yes" />
      
      <!-- Universal Mobile Web App Configuration -->
      <meta name="mobile-web-app-capable" content="yes" />
      <meta name="format-detection" content="telephone=no" />
      <meta name="theme-color" content="#ffffff" />
      
      <!-- Prevent WebFont flashes from blanking the card -->
      <style>
        /* Force font-display swap for better loading */
        * { font-display: swap !important; }
      </style>
  <title>RoastPortal – Personalized Coffee Quiz | Find Your Perfect Roast</title>

  <!-- ╔═════════════ SEO & Social ═════════════╗ -->
  <meta name="description"  content="Discover your ideal coffee roast with our interactive quiz and personalized recommendations.">
  <meta name="keywords"     content="coffee, roasting, personalized, quiz, beans, brew">
  <meta property="og:title"       content="RoastPortal – Personalized Coffee Quiz | Find Your Perfect Roast">
  <meta property="og:description" content="Take the RoastPortal quiz to get a custom coffee profile crafted just for you">
  <meta property="og:image"       content="https://roastportal.com/images/og-image.jpg">
  <meta property="og:url"         content="https://roastportal.com/">
  <meta name="twitter:card"       content="summary_large_image">
  <meta name="twitter:title"      content="RoastPortal – Personalized Coffee Quiz | Find Your Perfect Roast">
  <meta name="twitter:description"content="Take the RoastPortal quiz to get a custom coffee profile crafted just for you.">
  <meta name="twitter:image"      content="https://roastportal.com/images/og-image.jpg">
  <link rel="canonical" href="https://roastportal.com/">
  <link rel="icon" type="image/png" href="images/favicon.png">

  <!-- ╔═════════════ Google Analytics 4 ═════════════╗ -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-5LTTX2TGVQ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-5LTTX2TGVQ', {
      send_page_view: false,    // we'll fire manually if you like
      anonymize_ip: true
    });
  </script>
  <script>
    function trackGA4(eventName, params = {}) {
      gtag('event', eventName, params);
      // optional: console.log('[GA4]', eventName, params);
    }
  </script>

  <!-- ╔═════════════ Fonts & Tailwind ═════════════╗ -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@700;900&display=swap"  rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600&display=swap"     rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Kanit:wght@0,400;0,600;0,700;1,600&display=swap" rel="stylesheet">

  <!-- ╔═════════════ Page‑specific CSS ═════════════╗ -->
  <style>
  .container {
    width: 100%;
    max-width: 1440px; /* Adjust this value as you see fit */
    margin-left: auto;
    margin-right: auto;
    padding-left: 1.5rem; /* px-6 = 1.5rem */
    padding-right: 1.5rem;
  }
    :root{--brand-dark:#2b1608;--brand-light:#f5f0ea}
    .pill-input input{display:none}
    .pill-input input:checked + span{background:#22c55e;color:#fff;border-color:#22c55e}
    .pill-input label span{transition:.2s;padding:.5rem 1.25rem;border-radius:9999px;border:1px solid #d1d5db;cursor:pointer;display:inline-block}
    .question{display:none;min-height:200px}.question.active{display:block}
    .wordmark{font-family:'Kanit','Poppins','Nunito',sans-serif;font-size:clamp(1.25rem, 4vw, 2rem);letter-spacing:.04em;text-transform:uppercase;line-height:1.1;white-space:nowrap}
    .wordmark .roast,.wordmark .portal{color:#1a0f05;margin:0;padding:0;display:inline}
    html{scroll-padding-top:80px}html,body{font-family:'Kanit','Poppins','Nunito','Playfair Display',sans-serif}
    textarea{font-size:1.15rem;padding:0.75rem 1rem !important;border:2px solid #d1d5db;border-radius:.75rem;background:#f8fafc;color:#2b1608;transition:border .2s,box-shadow .2s;min-height:4.5rem;text-align:left;box-sizing:border-box}
    textarea:focus{outline:none;border-color:#d1d5db;box-shadow:0 0 0 2px #bbf7d0;background:#fff;text-align:left}
    #quizCard{height:480px;padding:1.5rem;overflow-y:auto;display:flex;flex-direction:column}
    #quizCard > div{flex:1;display:flex;flex-direction:column;justify-content:center;min-height:100%}
    #quizCard .custom-roast-content{justify-content:center;min-height:auto}
    @keyframes fadeInLoadingMsg{from{opacity:0;transform:translateY(16px)}to{opacity:1;transform:translateY(0)}}
    .sequential-fade-in{opacity:0;animation:fadeInLoadingMsg .7s ease forwards}
    /* hero wave animation */
    @keyframes wave1{
      0%{transform:translateX(0)}
      100%{transform:translateX(200vw)}
    }
    @keyframes wave2{
      0%{transform:translateX(0)}
      100%{transform:translateX(200vw)}
    }
    @keyframes wave3{
      0%{transform:translateX(0)}
      100%{transform:translateX(200vw)}
    }
    @keyframes wave4{
      0%{transform:translateX(0)}
      100%{transform:translateX(200vw)}
    }
    @keyframes wave5{
      0%{transform:translateX(0)}
      100%{transform:translateX(200vw)}
    }
    @keyframes wave6{
      0%{transform:translateX(0)}
      100%{transform:translateX(200vw)}
    }
    
    /* Dot animations - positioned at front of lines */
    @keyframes dot1{
      0%{transform:translateX(0vw)}
      100%{transform:translateX(200vw)}
    }
    @keyframes dot2{
      0%{transform:translateX(0vw)}
      100%{transform:translateX(200vw)}
    }
    @keyframes dot3{
      0%{transform:translateX(0vw)}
      100%{transform:translateX(200vw)}
    }
    @keyframes dot4{
      0%{transform:translateX(0vw)}
      100%{transform:translateX(200vw)}
    }
    @keyframes dot5{
      0%{transform:translateX(0vw)}
      100%{transform:translateX(200vw)}
    }
    @keyframes dot6{
      0%{transform:translateX(0vw)}
      100%{transform:translateX(200vw)}
    }
    .wave-line{position:absolute;height:2px;background:linear-gradient(to right, transparent 0%, rgba(34,197,94,0.05) 10%, rgba(34,197,94,0.1) 30%, rgba(34,197,94,0.2) 60%, rgba(34,197,94,0.3) 90%, rgba(34,197,94,0.3) 99.8%, rgba(255,255,255,1) 100%);width:100vw;top:0;left:-100vw;z-index:1}
    .wave-line:nth-child(1){animation:wave1 8s linear infinite;top:10%}
    .wave-line:nth-child(2){animation:wave2 12s linear infinite 1.5s;top:20%}
    .wave-line:nth-child(3){animation:wave3 10s linear infinite 3s;top:28%}
    .wave-line:nth-child(4){animation:wave4 14s linear infinite 5s;top:70%}
    .wave-line:nth-child(5){animation:wave5 9s linear infinite 7s;top:85%}
    .wave-line:nth-child(6){animation:wave6 11s linear infinite 9s;top:95%}
    
    /* Full-screen quiz styles */
    .quiz-fullscreen {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      background: #fff;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      overflow-y: auto;
      padding-block: 1rem; /* minimal padding */
      box-sizing: border-box;
    }
    

 
    .quiz-fullscreen #quizForm {
      width: 100%;
      max-width: 100vw;
      padding-left: 1rem;
      padding-right: 1rem;
      box-sizing: border-box;
    }
 
    .quiz-fullscreen #quizCard {
      flex: 1 1 auto;
      min-height: auto;
      width: 100%;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      overflow-y: auto;
      padding-top: 1rem;
    }

    .quiz-fullscreen .flex.justify-between {
      flex-shrink: 0;
      height: auto;
      align-items: center;
      margin-top: 0;
      display: flex !important;
      justify-content: center;
      width: auto;
      gap: 1rem;
    }

    .quiz-fullscreen .flex.justify-between .sm\\:ml-auto {
      order: 2;
    }

    .quiz-fullscreen .flex.justify-between #nextBtn {
      order: 1;
      display: block !important;
      flex-shrink: 0;
      min-width: fit-content;
    }

    .quiz-fullscreen .flex.justify-between #prevBtn {
      order: 2;
      display: block !important;
      flex-shrink: 0;
      min-width: fit-content;
    }
 
    .quiz-fullscreen #quizCard > * {
      width: 100%;
      min-height: auto;
      display: flex;
      flex-direction: column;
    }
 
    .quiz-fullscreen #quizCard .question-body {
      flex: 1;
      display: flex;
      justify-content: flex-start;
      align-items: center;
      width: 100%;
      overflow: visible; /* Allow bubble to show */
      min-height: auto;
    }
    
    .quiz-fullscreen .pill-input {
      max-height: 40vh; /* much smaller max height */
      overflow-y: auto; /* allow scrolling when needed */
    }
    
    .quiz-fullscreen .space-y-6 {
      max-height: 40vh; /* much smaller max height */
      overflow-y: auto; /* allow scrolling when needed */
    }
    
    .quiz-fullscreen #contactForm {
      max-width: 24rem;
      width: 100%;
      margin: 0 auto;
      padding: 2rem;
      background: white;
      border-radius: 1rem;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }
    
    .quiz-escape {
      position: fixed;
      top: 0.5rem;
      right: 0.5rem;
      background: rgba(255, 255, 255, 0.6);
      border: 1px solid rgba(229, 231, 235, 0.5);
      border-radius: 50%;
      width: 2rem;
      height: 2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 1rem;
      color: #9ca3af;
      z-index: 10000;
    }
    
    .quiz-escape:hover {
      background: rgba(255, 255, 255, 0.8);
      border-color: rgba(209, 213, 219, 0.8);
      color: #6b7280;
    }
    
    /* Override fullscreen button display for review state */
    .quiz-fullscreen #buttonContainer.hidden {
      display: none !important;
    }
    
    .quiz-fullscreen #buttonContainer.hidden #nextBtn,
    .quiz-fullscreen #buttonContainer.hidden #prevBtn,
    .quiz-fullscreen #buttonContainer.hidden #submitBtn {
      display: none !important;
    }
    
    /* Ensure hidden class takes precedence over inline styles */
    .hidden {
      display: none !important;
    }
    
    /* Defensive CSS for Previous button */
    #prevBtn.hidden {
      display: none !important;
    }
    
    /* Always win against the earlier rule */
    .quiz-fullscreen .flex.justify-between #prevBtn.hidden {
      display: none !important;
    }
    
    /* Progress bar fade out animation */
    @keyframes fadeOut {
      0% { opacity: 1; transform: scaleY(1); }
      100% { opacity: 0; transform: scaleY(0); }
    }
    
    .progress-fade-out {
      animation: fadeOut 1s ease-in-out forwards;
    }
    
    /* Fullscreen fade out animation */
    @keyframes fullscreenFadeOut {
      0% { 
        opacity: 1; 
        transform: scale(1);
      }
      100% { 
        opacity: 0; 
        transform: scale(0.95);
      }
    }
    
    .fullscreen-fade-out {
      animation: fullscreenFadeOut 0.8s ease-in-out forwards;
    }
    
    /* Ensure range slider container doesn't clip the label */
    .relative.flex-grow.h-32 {
      overflow: visible !important;
    }
    
    /* Additional styling for range slider labels */
    .output-bubble {
      white-space: nowrap;
      pointer-events: none;
    }

    .output-bubble::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border-width: 6px;
      border-style: solid;
      border-color: #16a34a transparent transparent transparent;
    }
    
        /* Force all range slider containers to not clip */
    .question-body .relative {
      overflow: visible !important;
    }

    /* Custom slider for a more standard look */
    .standard-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      cursor: pointer;
      outline: none;
      border-radius: 3px;
      height: 6px; /* Standard 6px track height */
      background: #d1d5db;
    }

    /* Thumb for Webkit browsers */
    .standard-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      height: 20px; /* Standard 20px thumb */
      width: 20px;
      background-color: #22c55e;
      border-radius: 50%;
      border: none;
      margin-top: -7px; /* Centers thumb on the track */
      box-shadow: 0 0 2px rgba(0,0,0,0.1);
      transition: all .2s ease;
    }
    .standard-slider:hover::-webkit-slider-thumb {
       box-shadow: 0 0 4px rgba(34, 197, 94, 0.3);
       transform: scale(1.2);
    }

    /* Thumb for Firefox */
    .standard-slider::-moz-range-thumb {
      height: 20px; /* Standard 20px thumb */
      width: 20px;
      background-color: #22c55e;
      border-radius: 50%;
      border: none;
      box-shadow: 0 0 2px rgba(0,0,0,0.1);
      transition: all .2s ease;
    }
    .standard-slider:hover::-moz-range-thumb {
       box-shadow: 0 0 4px rgba(34, 197, 94, 0.3);
    }

    /* Flavor slider styling */
    input[type="range"].accent-\[#22c55e\] {
      -webkit-appearance: none !important;
      appearance: none !important;
      width: 100% !important;
      cursor: pointer !important;
      outline: none !important;
      border-radius: 0.5px !important;
      height: 6px !important; /* Ultra thin track */
      background: #d1d5db !important;
      border: none !important;
    }

    /* Thumb for Webkit browsers */
    input[type="range"].accent-\[#22c55e\]::-webkit-slider-thumb {
      -webkit-appearance: none !important;
      appearance: none !important;
      height: 20px !important; /* Standard 20px thumb */
      width: 20px !important;
      background-color: #22c55e !important;
      border-radius: 50% !important;
      border: none !important;
      margin-top: -7px !important;
      box-shadow: 0 0 2px rgba(0,0,0,0.1) !important;
      transition: all .2s ease !important;
    }

    /* Thumb for Firefox */
    input[type="range"].accent-\[#22c55e\]::-moz-range-thumb {
      height: 20px !important; /* Standard 20px thumb */
      width: 20px !important;
      background-color: #22c55e !important;
      border-radius: 50% !important;
      border: none !important;
      box-shadow: 0 0 2px rgba(0,0,0,0.1) !important;
      transition: all .2s ease !important;
    }

    /* Alternative selector for flavor sliders */
    .question-body input[type="range"] {
      -webkit-appearance: none !important;
      appearance: none !important;
      width: 100% !important;
      cursor: pointer !important;
      outline: none !important;
      border-radius: 15px !important;
      height: 6px !important;
      border: none !important;
    }

    .question-body input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none !important;
      appearance: none !important;
      height: 20px !important;
      width: 20px !important;
      background-color: #fff !important;
      border-radius: 50% !important;
      border: 2px solid #000 !important;
      margin-top: -7px !important;
      box-shadow: 0 0 5px rgba(0,0,0,0.1) !important;
      transition: box-shadow .2s !important;
    }

    .question-body input[type="range"]::-moz-range-thumb {
      height: 20px !important;
      width: 20px !important;
      background-color: #fff !important;
      border-radius: 50% !important;
      border: 2px solid #000 !important;
      box-shadow: 0 0 5px rgba(0,0,0,0.1) !important;
      transition: box-shadow .2s !important;
    }

    /* ───────── Mobile-first refactor ───────── */
    /* Dynamic viewport units (handles the mobile keyboard nicely) */
    :root{
      --vh: 1vh;                            /* JS keeps this in sync            */
      --safe-bottom: env(safe-area-inset-bottom, 0px);
    }

    /* Full‑screen quiz container */
    .quiz-fullscreen{
      position: fixed;                      /* keep it above the page           */
      inset: 0;
      height: 100lvh;                       /* always the largest available viewport */
      display: flex;
      flex-direction: column;
      overflow-y: auto;                     /* allow the page to scroll         */
      scroll-behavior: smooth;              /* nicer scrolling                  */
      padding-bottom: calc(var(--safe-bottom) + 5rem); /* space for buttons   */
      -webkit-overflow-scrolling: touch;   /* smooth scrolling on iOS          */
    }

    /* still allow old browsers to fall back */
    @supports not (height:100lvh){
      .quiz-fullscreen{height:100vh;}
    }

    /* Form grows / scrolls instead of being clipped */
    #quizForm{flex:1 1 auto; display:flex; flex-direction:column;}
    #quizCard{
      flex:1 1 auto;
      overflow-y:auto;              /* lets content scroll inside          */
      padding:1rem 0 6rem;          /* extra bottom room for fixed buttons */
      -webkit-overflow-scrolling: touch; /* smooth scrolling on iOS */
    }

    /* remove the rigid desktop height so small screens are never clipped */
    #quizCard{height:auto !important; overflow-y:auto !important;}

    /* Navigation buttons always in view - STABLE POSITIONING */
    #buttonContainer{
      position: fixed;                         /* always in same spot            */
      bottom: calc(var(--safe-bottom) + 1rem);
      left: 50%;
      transform: translateX(-50%);             /* center horizontally            */
      z-index: 20;
      background:#fff;                         /* readable over quiz content     */
      padding:.75rem 1rem;
      border-radius: 0.75rem;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      max-width: 90vw;
      width: auto;
      min-width: 280px;
      
      /* Stable positioning - no transitions during quiz */
      transition: none !important;            /* disable transitions to prevent jumping */
      will-change: auto;                      /* don't optimize for animations */
      
      /* Prevent button from moving unexpectedly */
      transform-origin: center bottom;         /* anchor to bottom   */
      backface-visibility: hidden;            /* prevent flickering             */
      -webkit-backface-visibility: hidden;    /* Safari support                 */
    }
    
    /* Stable positioning during quiz modes */
    body.quiz-active #buttonContainer,
    body.quiz-fullscreen #buttonContainer {
      position: fixed !important;
      bottom: calc(env(safe-area-inset-bottom, 0px) + 1rem) !important;
      transform: translateX(-50%) !important;
      transition: none !important;             /* no movement during quiz */
    }
    
    /* Ensure smooth transitions during keyboard events */
    body.keyboard-open #buttonContainer {
      transition: bottom 0.2s ease-out;       /* Faster transition when opening */
    }
    
    /* More stable positioning when keyboard closes */
    body:not(.keyboard-open) #buttonContainer {
      transition: bottom 0.4s ease-in-out;    /* Slower, smoother close transition */
    }

    /* make the two buttons sit next to each other nicely on narrow screens */
    #buttonContainer button{
      flex:1 1 45%;
      pointer-events: auto !important;
      cursor: pointer !important;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    /* Question body tweaks */
    .question-body{padding-inline: .5rem;}
    
    /* Extra bottom padding for multi-range sliders to prevent button overlap */
    .multi-range-container {
      padding-bottom: 3rem !important; /* Extra space for iPhone */
    }
    
    /* Additional margin for the last slider to ensure it's visible */
    .slider-with-end-labels:last-child {
      margin-bottom: 1rem;
    }

    /* Sliders - matches progress bar height (h-3 = 12px) */
    input[type="range"]{
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
      height: 12px; /* Match progress bar height (h-3 = 12px) */
      width: 100%;
      cursor: pointer;
      outline: none;
    }

    /* Ensure the visible track stays standard size but with larger touch area */
    input[type="range"]::-webkit-slider-track {
      height: 12px; /* Match progress bar height (h-3 = 12px) */
      background: #e5e7eb;
      border-radius: 6px;
      border: none;
      /* Larger invisible touch area for mobile */
      padding: 8px 0; /* Invisible vertical padding for easier touch */
      margin: -8px 0; /* Compensate for padding to keep visual position */
    }

    input[type="range"]::-moz-range-track {
      height: 12px; /* Match progress bar height (h-3 = 12px) */
      background: #e5e7eb;
      border-radius: 6px;
      border: none;
      /* Larger invisible touch area for mobile */
      padding: 8px 0; /* Invisible vertical padding for easier touch */
      margin: -8px 0; /* Compensate for padding to keep visual position */
    }

    /* Standard 20px thumb */
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      height: 20px;
      width: 20px;
      border-radius: 50%;
      background: #22c55e;
      border: 1px solid white;
      box-shadow: 0 1px 2px rgba(0,0,0,0.15);
      cursor: pointer;
      margin-top: -4px; /* Center on 12px track */
    }

    input[type="range"]::-moz-range-thumb {
      height: 20px;
      width: 20px;
      border-radius: 50%;
      background: #22c55e;
      border: 1px solid white;
      box-shadow: 0 1px 2px rgba(0,0,0,0.15);
      cursor: pointer;
      border: none; /* Override default border for Firefox */
    }


    input[type="text"], textarea{font-size:1rem;}
    
    /* Prevent iOS zoom on contact form inputs */
    .contact-input {
      font-size: 2x !important; /* Must be 16px+ to prevent iOS zoom */
      height: 2.5rem !important; /* Consistent height for all inputs */
      line-height: 1.25 !important; /* Consistent line height */
      -webkit-appearance: none;
      appearance: none;
      -webkit-tap-highlight-color: transparent; /* Remove iOS tap highlight */
      transform: translate3d(0, 0, 0); /* Force hardware acceleration for smooth animation */
      transition: all 0.2s ease; /* Smooth focus transitions */
      box-sizing: border-box; /* Include padding and border in height */
    }
    
    /* Ensure consistent focus behavior on mobile */
    .contact-input:focus {
      transform: translate3d(0, 0, 0); /* Maintain position during focus */
      outline: none;
      border-color: #d1d5db !important;
      box-shadow: 0 0 0 2px #bbf7d0 !important;
    }
    
    /* Error state styling */
    .contact-input.error {
      border-color: #ef4444 !important;
      box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2) !important;
    }

    /* leave a "landing pad" under each input for scroll‑into‑view */
    input, textarea{
      scroll-margin-block-end: 8rem;     /* space for nav + keyboard       */
    }

    /* Gentle visual cues while typing */
    body.keyboard-open #buttonContainer{
      box-shadow:0 -2px 16px rgba(0,0,0,.15);
    }

    /* Unified focus styling for all text inputs */
    input[type="text"]:focus,
    input[type="email"]:focus,
    input[type="tel"]:focus,
    input[type="password"]:focus,
    textarea:focus {
      outline: none !important;
      border-color: #d1d5db !important;
      box-shadow: 0 0 0 2px #bbf7d0 !important;

    }

    /* Misc mobile polish */
    body{overscroll-behavior:contain;}  /* prevents iOS "bounce" trapping    */
    
    /* UNIVERSAL Pull-to-Refresh Prevention - Page Level Only */
    body.quiz-active,
    body.quiz-fullscreen {
      /* Standard CSS overscroll prevention */
      overscroll-behavior-y: none !important; 
      overscroll-behavior: none !important; 
      
      /* Prevent bounce/elastic scrolling */
      -webkit-overscroll-behavior: none !important;
      -webkit-overscroll-behavior-y: none !important;
      
      /* Chrome-specific pull-to-refresh prevention */
      overscroll-behavior-block: none !important;
      overscroll-behavior-inline: none !important;
    }
    
    /* Apply to document root for universal coverage */
    body.quiz-active html,
    body.quiz-fullscreen html {
      overscroll-behavior-y: none !important;
      overscroll-behavior: none !important;
      -webkit-overscroll-behavior: none !important;
      -webkit-overscroll-behavior-y: none !important;
    }
    
    /* ALLOW normal scrolling within quiz content */
    body.quiz-active #quizCard,
    body.quiz-fullscreen #quizCard,
    body.quiz-active #quizForm,
    body.quiz-fullscreen #quizForm {
      /* Reset to allow normal scrolling */
      overscroll-behavior: auto !important;
      overscroll-behavior-y: auto !important;
      -webkit-overflow-scrolling: touch !important;
      touch-action: auto !important;
      overflow-y: auto !important;
      scroll-behavior: smooth !important;
    }
    
    /* Special allowance for blend content */
    body.quiz-active .custom-roast-content,
    body.quiz-fullscreen .custom-roast-content,
    body.quiz-active .custom-roast-content *,
    body.quiz-fullscreen .custom-roast-content * {
      touch-action: auto !important;
      overscroll-behavior: auto !important;
      -webkit-overflow-scrolling: touch !important;
    }

    /* Name your blend page optimizations */
    .custom-roast-content .space-y-2 > * + * {
      margin-top: 0.5rem;
    }
    
    /* Optimize spacing for blend naming page */
    #quizCard:has(.custom-roast-content) {
      padding-top: 0.5rem !important; /* Minimal top padding for maximum space */
      padding-bottom: 8rem !important; /* More space for buttons */
      height: auto !important; /* Let content determine height */
      max-height: none !important; /* Remove height restrictions */
      overflow-y: auto !important; /* Ensure scrolling works */
      overflow-x: hidden !important; /* Prevent horizontal scroll */
      -webkit-overflow-scrolling: touch !important; /* Smooth iOS scrolling */
      overscroll-behavior: auto !important; /* Allow internal scrolling */
      touch-action: auto !important; /* Allow all touch gestures within */
    }
    
    .custom-roast-content {
      padding-bottom: 2rem !important; /* Reduced bottom space for mobile */
      margin-bottom: 2rem !important; /* More bottom margin for safety */
      min-height: auto !important; /* Let content flow naturally */
      overflow-y: visible !important; /* Ensure content is visible */
      touch-action: auto !important; /* Allow normal touch behavior */
      -webkit-overflow-scrolling: touch !important; /* Smooth scrolling */
    }
    
    /* Optimized spacing between elements on blend page */
    .custom-roast-content .space-y-2 > * + * {
      margin-top: 0.35rem !important; /* Tight but readable spacing */
    }
    
    /* Ensure blend title has proper spacing */
    .custom-roast-content h4 {
      margin-bottom: 0.5rem !important;
    }
    
    /* Creator's note at bottom needs extra margin for safety */
    .custom-roast-content .text-center:last-child {
      margin-bottom: 2rem !important; /* Reduced margin for more space */
    }

    /* Blend name suggestion chips - Enhanced for mobile */
    .suggestion-chip {
      font-size: 0.75rem;
      white-space: nowrap;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      touch-action: manipulation;
      min-height: 32px; /* Ensure touch target is large enough */
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    
    .suggestion-chip:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .suggestion-chip:active {
      transform: translateY(0) scale(0.95);
    }

    /* Additional mobile optimizations for blend page */
    .flavor-profile-fallback {
      -webkit-overflow-scrolling: touch;
    }

    /* Ensure minimum height for content areas to prevent blank rendering */
    .custom-roast-content {
      min-height: 300px;
    }
    
    /* Enhanced styling for blend name input to ensure visibility */
    .custom-roast-content input[name="blendName"] {
      font-size: 1rem !important;
      min-height: 2.5rem !important;
      padding: 0.75rem 1rem !important;
      border-width: 2px !important;
      background-color: #fff !important;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important;
    }
    
    .custom-roast-content input[name="blendName"]:focus {
      border-color: #22c55e !important;
      box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.1) !important;
      background-color: #fff !important;
    }
    
    /* Checkout form specific styling for better mobile experience */
    #quizCard:has(.contact-input) {
      padding-bottom: 10rem !important; /* Extra space for checkout form to prevent bouncing */
    }
    
    /* Ensure checkout form inputs are properly sized */
    .contact-input {
      font-size: 1rem !important;
      min-height: 2.5rem !important;
      padding: 0.75rem 1rem !important;
      border-width: 2px !important;
      background-color: #fff !important;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important;
    }
    
    .contact-input:focus {
      border-color: #22c55e !important;
      box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.1) !important;
      background-color: #fff !important;
    }
    
    /* Reduce spacing between personality title and radar chart on mobile */
    .custom-roast-content h4 {
      margin-bottom: 0.25rem !important; /* Reduced from 0.5rem (mb-2) */
    }
    
    .custom-roast-content .flex.justify-center {
      margin-bottom: 0.5rem !important; /* Reduced from 0.75rem (mb-3) */
    }

    /* Loading animation for better UX */
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .animate-pulse {
      animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }

    /* ╔═════════════  Small phones (≤ 360 px)  ═════════════╗ */
    @media (max-width: 360px){

      /* Shrink the global type scale a notch so long labels wrap less */
      html{font-size:15px;}

      /* ─── 1. SINGLE RANGE questions  ─── */
      /* Original markup:
         <span>min</span> <div class="relative">slider</div> <span>max</span>
         lives inside .flex.items-end                                         */
      .question-body .flex.items-end{
          /* turn row into 2‑row grid: slider on top, labels below */
          display:grid;
          grid-template-areas:
            "slider"
            "labels";
          row-gap:.25rem;
      }
      .question-body .flex.items-end .relative{grid-area:slider;}

      /* both <span> elements share the "labels" row; we push them to the edges */
      .question-body .flex.items-end > span{grid-area:labels;}
      .question-body .flex.items-end > span:first-child{justify-self:start;}
      .question-body .flex.items-end > span:last-child {justify-self:end;}

      /* make sure the slider track is full‑width and touch‑friendly */
      .question-body .flex.items-end .relative input[type="range"]{
          width:100%;
      }

      /* ─── 2. MULTI‑RANGE flavour sliders  ─── */
      /* Dislike | slider | Love‑it   →   slider
                                          Dislike       Love‑it             */
      .question-body .flex.items-center{
          display:grid;
          grid-template-areas:
            "slider"
            "labels";
          row-gap:.25rem;
      }
      .question-body .flex.items-center input[type="range"]{grid-area:slider;}
      .question-body .flex.items-center span{grid-area:labels;}
      .question-body .flex.items-center span:first-child{justify-self:start;}
      .question-body .flex.items-center span:last-child {justify-self:end;}

      /* ─── 3. Navigation buttons need a tad more room ─── */
      #buttonContainer button{padding-inline:.75rem;}

      /* ─── 4. Name your blend page ultra-compact ─── */
      /* Even tighter spacing for small screens */
      .custom-roast-content .space-y-2 > * + * {
        margin-top: 0.2rem !important;
      }
      
      /* Reduce top padding even more on small screens */
      #quizCard:has(.custom-roast-content) {
        padding-top: 0.5rem !important; /* Reasonable top padding */
        padding-bottom: 9rem !important; /* Extra space for buttons on mobile */
      }
      
      .custom-roast-content h3 {
        font-size: 0.875rem !important;
        margin-bottom: 0.125rem !important;
      }
      
      .custom-roast-content h4 {
        font-size: 0.75rem !important;
        margin-bottom: 0.25rem !important; /* Small bottom margin */
      }
      
      .custom-roast-content p {
        font-size: 0.625rem !important;
        line-height: 1.3 !important;
        padding-left: 0.5rem !important;
        padding-right: 0.5rem !important;
        margin-top: 0.25rem !important;
      }
      
      /* Reduced spacing for small phones */
      #quizCard:has(.custom-roast-content) {
        padding-bottom: 8rem !important; /* Adequate bottom clearance for tiny screens */
      }
      
      .custom-roast-content {
        padding-bottom: 2rem !important; /* Adequate bottom space for small iPhones */
        margin-bottom: 2rem !important; /* Adequate safety margin */
      }
      
      /* Even tighter spacing for ultra-compact layout */
      .custom-roast-content .space-y-2 > * + * {
        margin-top: 0.25rem !important; /* Minimal spacing to fit everything */
      }
      
      /* Ensure creator's note has adequate clearance on small screens */
      .custom-roast-content .text-center:last-child {
        margin-bottom: 3rem !important; /* Adequate margin for more space */
        padding-bottom: 1.5rem !important; /* Adequate padding */
      }
      
      /* Enhanced blend name input for small screens */
      .custom-roast-content input[name="blendName"] {
        font-size: 0.875rem !important;
        min-height: 2.25rem !important;
        padding: 0.5rem 0.75rem !important;
      }
      
      /* Ultra-tight spacing for small screens */
      .custom-roast-content h4 {
        margin-bottom: 0.125rem !important; /* Minimal spacing */
      }
      
      .custom-roast-content .flex.justify-center {
        margin-bottom: 0.25rem !important; /* Minimal spacing */
      }
      
      /* Checkout form spacing for small screens */
      #quizCard:has(.contact-input) {
        padding-bottom: 12rem !important; /* Extra space for small screens to prevent bouncing */
      }
      
      .contact-input {
        font-size: 0.875rem !important;
        min-height: 2.25rem !important;
        padding: 0.5rem 0.75rem !important;
      }

    }

    /* ╔═════════════  Consistent desktop card (≥ 640 px)  ═════════════╗ */
    @media (min-width: 640px){
    
      /* COMPACT LAYOUT: Center everything with minimal waste */
      #quiz {
        min-height: 100vh;           /* Full viewport height for centering */
        display: flex;
        flex-direction: column;
        justify-content: center;     /* Center the content vertically */
        padding: 2rem 0;             /* Minimal top/bottom padding */
      }
      
      #quizForm {
        margin: 0 auto;              /* Center the form */
      }
      
      /* Compact quiz title */
      #quizTitle {
        margin-bottom: 2rem !important;  /* Reduced gap to quiz card */
        font-size: 2rem !important;      /* Slightly smaller title */
      }

      /* Card itself (on desktop the height stops changing) */
      #quizCard{
        max-width: 28rem;            /* 448 px – looks tidy next to 16 px base type  */
        height: 540px;               /* one neat "playing card"                       */
        padding: 2rem 2.25rem 2rem;  /* consistent padding                            */
        margin-inline:auto;
        margin-bottom: 4rem;         /* REDUCED: compact spacing for buttons         */
        overflow-y:auto;             /* allow scrolling when needed                   */
        background:#fff;
        border-radius:1.25rem;
        box-shadow:0 6px 24px rgba(0,0,0,.08);
      }

      /* Give the top stack (title + help note) a fixed slot               */
      #quizCard h3{
        font-size:1.25rem;
        line-height:1.4;
        font-weight:600;
        text-align:center;
        margin:0 0 .5rem;
        min-height:3.5rem;           /* ══  Title area never shrinks / grows  ══      */
        display:flex;align-items:center;justify-content:center;
      }

      /* Any sub‑note <p> we inject right after the <h3> lives here         */
      #quizCard h3 + p{
        font-size:.875rem;
        text-align:center;
        color:#6b7280;
        min-height:2rem;             /* fixed, so other questions without a note
                                        leave the same gap                               */
        display:flex;align-items:center;justify-content:center;
        margin-bottom:1rem;
      }

      /* The interactive block expands/contracts but keeps min height       */
      .question-body{
        flex:1 1 auto;
        min-height:0;                /* allow internal scroll on overflow             */
        display:flex;align-items:center;justify-content:center;
        width:100%;
      }

      /* Radio / pill wrappers never spill vertically                       */
      .pill-input{max-height:100%; overflow:auto; padding:.25rem;}

      /* Single & multi‑range sliders stay centered                         */
      .question-body .flex.items-end,
      .question-body .flex.items-center{width:100%;}

      /* IMPROVED: Navigation bar with consistent positioning for muscle memory */
      #buttonContainer{
        position: fixed;               /* Fixed position for consistent location */
        bottom: 2rem;                  /* REDUCED: Much closer to quiz card */
        left: 50%;                     /* Center horizontally */
        transform: translateX(-50%);   /* Perfect centering */
        max-width: 28rem;
        width: auto;
        min-width: 320px;
        margin: 0;                     /* Remove margin - using fixed positioning */
        background:#fff;
        padding:.75rem 1rem;
        border-radius: 0.75rem;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        z-index: 20;
      }
      #buttonContainer button{
        height: 3rem;
        min-width: 120px;
      }

      /* Body text inputs: make them a touch taller so the card still looks balanced */
      input[type="text"], textarea{padding-block:.75rem;}

      /* Review & checkout screens inherit the same frame automatically     */
    }
  </style>
</head>

<body class="font-sans antialiased text-gray-800 bg-gray-50">

<!-- ╔═════════════ HEADER ═════════════╗ -->
<header class="bg-white shadow sticky top-0 z-50">
  <nav class="container mx-auto flex justify-between items-center py-3 px-6 md:py-3 md:px-8" aria-label="Main navigation">
    <a href="#hero" class="flex items-center gap-4" aria-label="RoastPortal Home">
      <img src="images/favicon.png" alt="RoastPortal logo" class="h-10" loading="lazy">
      <span class="wordmark"><span class="roast">Roast</span> <span class="portal">Portal</span></span>
    </a>
    <a class="text-[#1a0f05] font-semibold hover:underline px-4 py-2 rounded transition-colors cursor-pointer" id="loginBtn">Login</a>
  </nav>
</header>

<!-- ╔═════════════ LOGIN MODAL ═════════════╗ -->
<div id="loginModal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden flex items-center justify-center">
  <div class="bg-white rounded-lg shadow-2xl w-full max-w-md mx-4">
    <div class="flex items-center justify-between p-6 border-b border-gray-200">
      <h2 class="text-xl font-semibold text-gray-800">Sign In</h2>
      <button id="closeLoginModal" class="text-gray-400 hover:text-gray-600 text-2xl font-bold">&times;</button>
    </div>
    
    <form id="loginForm" class="p-6">
      <div class="mb-4">
        <label for="loginEmail" class="block text-sm font-medium text-gray-700 mb-2">Email Address</label>
        <input type="email" id="loginEmail" name="email" required class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-green-200 focus:border-green-500">
      </div>
      
      <div class="mb-6">
        <label for="loginPassword" class="block text-sm font-medium text-gray-700 mb-2">Password</label>
        <input type="password" id="loginPassword" name="password" required class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-green-200 focus:border-green-500">
      </div>
      
      <div id="loginError" class="hidden mb-4 p-3 bg-red-50 border border-red-200 rounded-md">
        <p class="text-red-600 text-sm">User not found. Please check your credentials and try again.</p>
      </div>
      
      <button type="submit" class="w-full bg-[#22c55e] text-white py-2 px-4 rounded-md hover:bg-[#16a34a] transition-colors font-medium">
        Sign In
      </button>
      
      <div class="mt-4 text-center">
        <a href="#" class="text-sm text-[#22c55e] hover:underline">Forgot your password?</a>
      </div>
    </form>
  </div>
</div>

<!-- ╔═════════════ HERO ═════════════╗ -->
    <section id="hero" class="relative min-h-[60vh] flex items-center justify-center overflow-hidden">
  <div class="absolute inset-0 w-full h-full" style="background-color: #2d1f14;"></div>
      <div aria-hidden="true" class="absolute inset-0 pointer-events-none">
      <div class="wave-line"></div>
      <div class="wave-line"></div>
      <div class="wave-line"></div>
      <div class="wave-line"></div>
      <div class="wave-line"></div>
      <div class="wave-line"></div>
    </div>
  <span class="sr-only">Background showing roasted coffee beans and a steaming mug</span>

  <div class="relative z-10 text-center px-6 py-32">
    <h1 class="text-4xl md:text-6xl font-bold text-white drop-shadow mb-8" style="font-family:'Poppins',sans-serif;font-weight:600">
      Data‑driven coffee,<br>roasted for <span class="text-[#22c55e] drop-shadow font-extrabold">you</span>
    </h1>
    <p class="text-lg md:text-2xl text-white mb-10 drop-shadow">
      Answer a few questions, sip, rate, repeat — our AI optimizes your coffee until it’s perfect for you.
    </p>
    <button id="heroButton" class="bg-[#16a34a] text-white px-6 py-3 rounded-full font-medium text-lg hover:bg-[#22c55e] transition-colors cursor-pointer">Create your custom blend</button>
  </div>
</section>

<!-- ╔═════════════ HOW IT WORKS ═════════════╗ -->
<section id="how-it-works" class="py-16 bg-gray-100">
  <div class="container mx-auto px-6">
    <h2 class="text-3xl font-bold text-center mb-12">How it works</h2>
    <div class="grid grid-cols-1 md:grid-cols-3 gap-10">
      <article class="text-center p-6 bg-white rounded-lg shadow-lg">
        <div class="text-5xl font-extrabold text-[#2b1608] mb-4">1</div>
        <h3 class="text-xl font-semibold mb-2">Describe your ideal coffee</h3>
        <p class="text-gray-600 text-base px-4">Tell our AI what you like</p>
      </article>
      <article class="text-center p-6 bg-white rounded-lg shadow-lg">
        <div class="text-5xl font-extrabold text-[#2b1608] mb-4">2</div>
        <h3 class="text-xl font-semibold mb-2">Enjoy your unique coffee</h3>
        <p class="text-gray-600 text-base px-4">We send coffee crafted just for you</p>
      </article>
      <article class="text-center p-6 bg-white rounded-lg shadow-lg">
        <div class="text-5xl font-extrabold text-[#2b1608] mb-4">3</div>
        <h3 class="text-xl font-semibold mb-2">Optimize your coffee</h3>
        <p class="text-gray-600 text-base px-4">Give feedback and we’ll keep improving your coffee</p>
      </article>
    </div>
  </div>
</section>

<!-- ╔═════════════ QUIZ ═════════════╗ -->
<section id="quiz" class="py-8 bg-white">
  <div class="container mx-auto px-6">
    <h2 id="quizTitle" class="text-3xl font-bold text-center mb-6">Train your coffee AI</h2>

    <!-- ▶ FORM 1 : QUIZ ◀ -->
    <form id="quizForm" class="class="w-full max-w-[1440px] mx-auto bg-white/90 shadow-xl rounded-2xl p-6 md:p-10 relative" aria-label="Coffee Preference Quiz">
      <button type="button" id="quizEscape" class="quiz-escape hidden" aria-label="Exit quiz">×</button>
      <input type="hidden" name="formType" value="quiz">
      <input type="hidden" name="userId" id="quizUserId">

      <!-- Progress bar -->
      <div class="w-full max-w-md mx-auto mb-6">
        <div class="w-full bg-gray-200 rounded-full h-3">
          <div id="progressBar" class="bg-[#22c55e] h-3 rounded-full transition-all" style="width:0%"></div>
        </div>
      </div>

      <!-- Dynamic question container -->
      <div id="quizCard" class="relative min-h-[220px] flex flex-col justify-center items-center"></div>

      <!-- Review Section (hidden by default) -->
      <div id="reviewSection" class="hidden">
        <div id="reviewContent" class="space-y-3 bg-gray-50 p-6 rounded-lg shadow-inner"></div>
        <div class="mt-6">
            <label for="blendName" class="block font-medium mb-1">Name your blend</label>
            <input type="text" id="blendName" name="blendName" class="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-green-200">
        </div>
      </div>


      <p id="errorMessage" class="hidden text-red-500 text-sm font-medium mt-2"></p>

      <!-- Navigation buttons -->
      <div class="w-full max-w-md mx-auto mt-6">
        <div id="buttonContainer" class="flex flex-col sm:flex-row justify-center gap-2">
          <button id="prevBtn" class="bg-gray-300 text-gray-800 px-6 py-3 rounded font-semibold w-full sm:w-auto order-2 sm:order-1" disabled>Previous</button>
          <button id="submitBtn" class="bg-[#22c55e] text-white px-6 py-3 rounded font-semibold w-full sm:w-auto order-1 sm:order-2 hidden" type="button">Next</button>
        </div>
      </div>
    </form>

    <!-- ▶ FORM 2 : CONTACT ◀ (hidden until quiz completes) -->
    <form id="contactForm" class="w-full max-w-[1440px] mx-auto bg-white/90 shadow-xl rounded-2xl p-6 md:p-10 relative hidden" aria-label="Contact Information Form">
      <input type="hidden" name="formType" value="contact">
      <input type="hidden" name="userId" id="contactUserId">
      
      <!-- Contact form content container -->
      <div class="max-w-md mx-auto">
        <h2 class="text-3xl font-bold text-center mb-8">Almost done! We need your details</h2>
        
        <div class="space-y-4">
      <div>
        <label class="block font-medium mb-1" for="contactName">Name</label>
        <input class="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-green-200" type="text" id="contactName" name="contactName" required>
      </div>
      <div>
        <label class="block font-medium mb-1" for="contactEmail">Email</label>
        <input class="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-green-200" type="email" id="contactEmail" name="contactEmail" required>
      </div>
      <div>
        <label class="block font-medium mb-1" for="contactPhone">Phone</label>
        <input class="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-green-200" type="tel" id="contactPhone" name="contactPhone" required>
      </div>

      <p id="contactError" class="hidden text-center text-red-500 font-semibold mt-2"></p>
      <p id="contactSuccess" class="hidden text-center text-[#16a34a] font-semibold mt-4">Thank you! We have your details.</p>
        </div>
      </div>
    </form>
  </div>
</section>

<!-- ╔═════════════ FAQ ═════════════╗ -->
<section class="container mx-auto px-6 max-w-3xl mt-12 mb-16" aria-label="Frequently Asked Questions">
  <h2 class="text-3xl font-bold text-center mb-8">FAQ</h2>
  <div class="space-y-4">
    <details class="border border-gray-200 rounded-lg p-4">
      <summary class="pl-2 font-semibold cursor-pointer">How does it work?</summary>
      <p class="mt-2 text-gray-600">
        You answer the quiz on this site. We send you your first personalized two-week supply of coffee. You try it and give us feedback about that specific coffee. We take your feedback and use AI to further improve how we roast coffee for you and make your unique blend of coffee. Your next delivery of coffee will be upgraded with the new changes. After you try it, you can give us feedback again and we will continue to improve your coffee until it is perfect for you.
      </p>
    </details>
    <details class="border border-gray-200 rounded-lg p-4">
      <summary class="pl-2 font-semibold cursor-pointer">What makes you different from other coffee subscription services?</summary>
      <p class="mt-2 text-gray-600">
        Other services have a fixed number of coffee blends to choose from and they try to help you find which blend you would like best. We start with what you tell us you are looking for and then create a blend just for you. When you give us feedback on your blend, we optimize your blend. Our goal is to work with you to create the perfect blend for you. 
      </p>
      <p class="mt-2 text-gray-600">
        One of the most challenging parts of making great coffee is choosing the perfect grind setting, the right water, and the right ratio of water to coffee for your specific brewing method. We do all of that for you. Expect to receive 12 individual doses of coffee, each prepared specifically for your brewing method and equipment.
      </p>
    </details>
    <details class="border border-gray-200 rounded-lg p-4">
      <summary class="pl-2 font-semibold cursor-pointer">What is a blend?</summary>
      <p class="mt-2 text-gray-600">
        Other roasters mix one or more types of coffee together that are roasted in a specific way to create a blend that the roaster likes and then sells to a mass market. We believe blends should be personal to each individual. We use the same levers to create a blend, but by using AI, we are able to create a blend that aligns with your taste preferences.
      </p>
    </details>
    <details class="border border-gray-200 rounded-lg p-4">
      <summary class="pl-2 font-semibold cursor-pointer">What if I want to have more than one blend?</summary>
      <p class="mt-2 text-gray-600">
        That’s easy. Just login and go into your settings to create a new blend. Any new blend you create will be optimized separately. You can specify how often you want us to send you each blend you have created.
      </p>
    </details>
    <details class="border border-gray-200 rounded-lg p-4">
      <summary class="pl-2 font-semibold cursor-pointer">Do I need to give feedback every time?</summary>
      <p class="mt-2 text-gray-600">
        No. If you don’t give feedback, we send you the same coffee as before.
      </p>
    </details>
    <details class="border border-gray-200 rounded-lg p-4">
      <summary class="pl-2 font-semibold cursor-pointer">How do I pause my subscription?</summary>
      <p class="mt-2 text-gray-600">
        Just turn on “vacation mode” in your settings.
      </p>
    </details>
    <details class="border border-gray-200 rounded-lg p-4">
      <summary class="pl-2 font-semibold cursor-pointer">How often will I get a delivery of coffee?</summary>
      <p class="mt-2 text-gray-600">
        After you give feedback on your current order of coffee, we start creating the next version of your coffee and send it to you when done. We package it to remain fresh until you need it. If you don’t provide any feedback, we estimate when you will be running low on coffee and try to time it so we send you more coffee before you run out.
      </p>
    </details>
    <details class="border border-gray-200 rounded-lg p-4">
      <summary class="pl-2 font-semibold cursor-pointer">How much does the coffee cost?</summary>
      <p class="mt-2 text-gray-600">
        You get to choose how much you pay. Paying more impacts how much we are able to optimize the quality of your coffee.
      </p>
    </details>
    <details class="border border-gray-200 rounded-lg p-4">
      <summary class="pl-2 font-semibold cursor-pointer">What sizes of coffee can I buy?</summary>
      <p class="mt-2 text-gray-600">
        Currently we only sell 2-week supplies of coffee. Please let us know if you would like to buy in bulk: <a class="underline" href="mailto:support@roastportal.com">support@roastportal.com</a>.
      </p>
    </details>
  </div>
</section>

<!-- ╔═════════════ FOOTER ═════════════╗ -->
<footer class="bg-gray-800 text-gray-200 py-4">
  <div class="container mx-auto px-6 flex flex-col md:flex-row justify-between items-center text-sm space-y-4 md:space-y-0">
    <a href="#hero" aria-label="Back to top"><img src="images/favicon.png" alt="RoastPortal logo" class="h-8" loading="lazy"></a>
    <p>© 2025 RoastPortal. All rights reserved.</p>
    <div class="flex space-x-4">
      <a href="terms.html" class="hover:underline">Terms</a>
      <a href="mailto:hello@roastportal.com" class="hover:underline">Contact</a>
    </div>
  </div>
</footer>

<!-- ╔═════════════ MAIN SCRIPT ═════════════╗ -->
<script>
/*------------------------------------------------------------------
  CONFIG
------------------------------------------------------------------*/
const GAS_URL     = 'https://script.google.com/macros/s/AKfycbyN5Mv6iJ7Wmj79jR6TY9PcXgK8-QaaKFSwqq8KRlzaPYidgCr6rcYlLePDqbDDzyNoaQ/exec'; // ← replace with your deployed Web‑App URL
const TAB_FORM    = 'FormResponses';
const TAB_CONTACT = 'ContactCapture';

/*------------------------------------------------------------------
  STATE & HELPERS
------------------------------------------------------------------*/
const quizData = [
  {label:'What roast level do you enjoy most?', type:'radio', name:'roastLevel', options:['Light','Light-Medium','Medium','Medium-Dark','Dark']},
  {label:'Tell us about your flavor preferences', type:'multi-range', names:['flavorNutty','flavorFruity','flavorFloral','flavorSmoky'], min:0,max:100,step:1,flavors:['Nutty','Fruity','Floral','Smoky']},
  {label:'How do you usually brew your coffee?', type:'radio', name:'brewMethod', options:['Drip','Pour-over','French Press','Espresso','Single-Serve Pod','Cold Brew','Other']},
  {label:'What brewing equipment do you have?', type:'text', name:'equipmentDetails'},
  {label:'How do you take your coffee? (select all that apply)', type:'checkbox', names:['addMilk','addDairyFree','addSugar'], options:['Milk / Cream','Dairy‑free Milk','Sugar / Syrup']},
  {label:'Tell our AI how much you want to spend per cup of coffee.', type:'range', name:'priceRange', min:8, max:36, step:1, left:'$2.00', right:'$9.00'},
  {label:'How many cups of coffee do you drink per day?', type:'radio', name:'cupsPerDay', options:[{text:'1 cup per day', value:'1'}, {text:'More than one cup per day', value:'2'}]},
  {label:'How adventurous are you with coffee?', type:'radio', name:'personality', options:['Stick to classics','Enjoy some variety',"Bring on the funk!"]},
  {label:'Which tastes do you prefer?',type:'radio', name:'tasteBalance', options:['Sweet & Smooth','Tart & Complex', 'Rich & Bitter']},
  {label:'Anything else we should know?', type:'text', name:'additionalNotes'},
  {label:'Name your blend', type:'text', name:'blendName'}
];
const defaults = {roastLevel:'Medium',brewMethod:'Drip',priceRange:20,cupsPerDay:'1',personality:'Enjoy some variety',
  flavorNutty:50,flavorFruity:50,flavorFloral:50,flavorSmoky:50,
  tasteBalance:'Sweet & Smooth',blendName:''
};

let current = 0;
let answers = {...defaults};
let isLoading = false; // Flag to track loading state
const userId = sessionStorage.getItem('userId') || (crypto.randomUUID?.() || Math.random().toString(36).slice(2));
sessionStorage.setItem('userId', userId);

/*------------------------------------------------------------------
  DOM SHORTCUTS
------------------------------------------------------------------*/
const quizForm      = document.getElementById('quizForm');
const contactForm   = document.getElementById('contactForm');
const quizCard      = document.getElementById('quizCard');
const progressBar   = document.getElementById('progressBar');
let prevBtn       = document.getElementById('prevBtn');
const nextBtn       = document.getElementById('nextBtn');
let submitBtn     = document.getElementById('submitBtn');
const errorMessage  = document.getElementById('errorMessage');
document.getElementById('quizUserId').value    = userId;
document.getElementById('contactUserId').value = userId;

/*------------------------------------------------------------------
  RENDERING
------------------------------------------------------------------*/

function generateBlendNameSuggestions(answers, flavors, primaryNotes) {
  try {
    // Validate inputs
    if (!answers || typeof answers !== 'object') {
      console.warn('Invalid answers object for blend suggestions');
      return ['Custom Blend', 'Perfect Balance', 'Personal Pick'];
    }

    if (!flavors || !Array.isArray(flavors)) {
      console.warn('Invalid flavors array for blend suggestions');
      return ['Custom Blend', 'Perfect Balance', 'Personal Pick'];
    }

    const suggestions = [];
    
    // Get personality-based suggestions
    const personalityNames = {
      'Bring on the funk!': ['Funk Master', 'Wild Explorer', 'Flavor Adventure', 'Bold Journey'],
      'Enjoy some variety': ['Artisan Blend', 'Crafted Choice', 'Balanced Discovery', 'Perfect Harmony'],
      'Stick to classics': ['Classic Comfort', 'Traditional Roast', 'Timeless Blend', 'Heritage Cup']
    };
  
  // Get roast level suggestions
  const roastNames = {
    'Light': ['Bright Morning', 'Sunrise Blend', 'Golden Hour'],
    'Light-Medium': ['Dawn Roast', 'Aurora Blend', 'First Light'],
    'Medium': ['Midday Magic', 'Perfect Balance', 'Golden Mean'],
    'Medium-Dark': ['Evening Blend', 'Twilight Roast', 'Dusk Special'],
    'Dark': ['Midnight Roast', 'Dark Knight', 'Bold Evening']
  };
  
  // Get flavor-based suggestions (avoiding trademark names)
  const topFlavor = flavors.sort((a, b) => b.value - a.value)[0];
  const flavorNames = {
    'Nutty': ['Hazelnut Dream', 'Nutty Delight', 'Pecan Perfect'],
    'Fruity': ['Berry Burst', 'Citrus Sunrise', 'Fruit Garden'],
    'Floral': ['Garden Bloom', 'Floral Fantasy', 'Spring Breeze'],
    'Smoky': ['Campfire Blend', 'Smoky Mountain', 'Fire Roast']
  };
  
  // Get brew method suggestions
  const brewNames = {
    'Drip': ['Daily Drip', 'Morning Ritual', 'Perfect Pour'],
    'Pour-over': ['Artisan Pour', 'Craft Coffee', 'Pour Perfection'],
    'French Press': ['Press Perfect', 'French Roast', 'Bold Press'],
    'Espresso': ['Shot Perfect', 'Espresso Elite', 'Café Supreme'],
    'Single-Serve Pod': ['Pod Perfect', 'Quick Brew', 'Instant Joy'],
    'Cold Brew': ['Chill Blend', 'Cold Comfort', 'Smooth Chill']
  };
  
  // Add personality suggestions
  if (answers.personality && personalityNames[answers.personality]) {
    suggestions.push(...personalityNames[answers.personality].slice(0, 2));
  }
  
  // Add roast level suggestions
  if (answers.roastLevel && roastNames[answers.roastLevel]) {
    suggestions.push(...roastNames[answers.roastLevel].slice(0, 2));
  }
  
  // Add flavor suggestions
  if (topFlavor && flavorNames[topFlavor.name]) {
    suggestions.push(...flavorNames[topFlavor.name].slice(0, 2));
  }
  
  // Add brew method suggestions
  if (answers.brewMethod && brewNames[answers.brewMethod]) {
    suggestions.push(...brewNames[answers.brewMethod].slice(0, 1));
  }
  
  // Add some creative combinations
  const creativeNames = [
    'My Perfect Cup',
    'Custom Creation',
    'Personal Blend',
    'Signature Roast',
    'Daily Special'
  ];
  suggestions.push(...creativeNames.slice(0, 2));
  
    // Remove duplicates and limit to 3 suggestions
    const uniqueSuggestions = [...new Set(suggestions)].filter(Boolean).slice(0, 3);
    
    // Ensure we always return at least some suggestions
    if (uniqueSuggestions.length === 0) {
      return ['Custom Blend', 'Perfect Balance', 'Personal Pick'];
    }
    
    return uniqueSuggestions;
    
  } catch (error) {
    console.error('Error generating blend name suggestions:', error);
    return ['Custom Blend', 'Perfect Balance', 'Personal Pick'];
  }
}

function renderBlendSuggestions(suggestions) {
  try {
    const container = document.getElementById('blendSuggestions');
    const input = document.getElementById('blendName');
    
    if (!container) {
      console.warn('Blend suggestions container not found');
      return;
    }
    
    if (!input) {
      console.warn('Blend name input not found');
      return;
    }
    
    if (!suggestions || !Array.isArray(suggestions) || suggestions.length === 0) {
      console.warn('No valid suggestions provided');
      container.innerHTML = '<span class="text-xs text-gray-400">No suggestions available</span>';
      return;
    }
    
    // Clear container first
    container.innerHTML = '';
    
    // Create suggestion chips with enhanced mobile support
    const chipElements = suggestions.map((suggestion, index) => {
      if (!suggestion || typeof suggestion !== 'string') {
        console.warn('Invalid suggestion:', suggestion);
        return null;
      }
      
      // Sanitize suggestion text
      const safeSuggestion = suggestion.replace(/[<>&"']/g, '');
      
      const chip = document.createElement('button');
      chip.type = 'button';
      chip.className = 'suggestion-chip px-2 py-1 text-xs bg-gray-100 hover:bg-green-500 hover:text-white border border-gray-300 rounded-full transition-colors cursor-pointer touch-manipulation';
      chip.textContent = safeSuggestion;
      chip.setAttribute('data-suggestion', safeSuggestion);
      chip.setAttribute('aria-label', `Use suggestion: ${safeSuggestion}`);
      
      // Enhanced touch/click handler for mobile
      const handleSelection = (event) => {
        event.preventDefault();
        event.stopPropagation();
        
        try {
          if (input && !input.disabled) {
            input.value = safeSuggestion;
            input.focus();
            
            // Update answers object safely
            if (typeof answers === 'object') {
              answers.blendName = safeSuggestion;
            }
            
            // Visual feedback with better mobile support
            chip.style.background = '#22c55e';
            chip.style.color = 'white';
            chip.style.transform = 'scale(0.95)';
            
            // Reset styles after animation
            setTimeout(() => {
              chip.style.background = '';
              chip.style.color = '';
              chip.style.transform = '';
            }, 200);
            
            // Trigger input event for any listeners
            const inputEvent = new Event('input', { bubbles: true });
            input.dispatchEvent(inputEvent);
          }
        } catch (selectionError) {
          console.warn('Error handling suggestion selection:', selectionError);
        }
      };
      
      // Add both click and touchend events for better mobile compatibility
      chip.addEventListener('click', handleSelection);
      chip.addEventListener('touchend', handleSelection);
      
      // Prevent default touch behavior to avoid double-firing
      chip.addEventListener('touchstart', (event) => {
        event.preventDefault();
      });
      
      return chip;
    }).filter(Boolean); // Remove null elements
    
    // Add chips to container
    chipElements.forEach((chip, index) => {
      container.appendChild(chip);
      
      // Add small delay between chips for better visual loading on slower devices
      if (index < chipElements.length - 1) {
        const spacer = document.createTextNode(' ');
        container.appendChild(spacer);
      }
    });
    
    // Ensure container is visible
    container.style.display = 'flex';
    container.style.visibility = 'visible';
    
  } catch (error) {
    console.error('Error rendering blend suggestions:', error);
    
    // Fallback: simple text-based suggestions
    const container = document.getElementById('blendSuggestions');
    if (container && suggestions && suggestions.length > 0) {
      container.innerHTML = suggestions.map(suggestion => 
        `<span class="px-2 py-1 text-xs bg-gray-100 border border-gray-300 rounded-full cursor-pointer hover:bg-green-100" 
               onclick="try{document.getElementById('blendName').value='${(suggestion || '').replace(/'/g, "\\'")}'; if(typeof answers !== 'undefined') answers.blendName='${(suggestion || '').replace(/'/g, "\\'")}';}catch(e){console.warn('Fallback click failed',e);}">${suggestion || 'Unknown'}</span>`
      ).join(' ');
    }
  }
}

function createRadarChart(flavors) {
    try {
        // Validate input
        if (!flavors || !Array.isArray(flavors) || flavors.length === 0) {
            throw new Error('Invalid flavors data');
        }

        const size = 260; // Increased size to accommodate labels
        const center = size / 2;
        const radius = size * 0.25; // Adjusted radius to keep chart centered
        const numAxes = flavors.length;
        const angleSlice = (Math.PI * 2) / numAxes;

        // Helper to calculate point coordinates with validation
        const getPoint = (value, index) => {
            if (typeof value !== 'number' || typeof index !== 'number') {
                throw new Error('Invalid point coordinates');
            }
            const angle = angleSlice * index - Math.PI / 2; // Start at the top
            const x = center + (value / 100) * radius * Math.cos(angle);
            const y = center + (value / 100) * radius * Math.sin(angle);
            
            // Ensure coordinates are valid numbers
            if (isNaN(x) || isNaN(y)) {
                throw new Error('Generated invalid coordinates');
            }
            
            return `${x.toFixed(2)},${y.toFixed(2)}`;
        };

        // --- SVG Parts with enhanced error checking ---
        // 1. Grid lines (concentric polygons)
        let gridLines = '';
        try {
            [25, 50, 75, 100].forEach(val => {
                const points = flavors.map((_, i) => getPoint(val, i)).join(' ');
                gridLines += `<polygon points="${points}" fill="none" stroke="#e5e7eb" stroke-width="1" vector-effect="non-scaling-stroke"/>`;
            });
        } catch (gridError) {
            console.warn('Grid lines generation failed:', gridError);
            gridLines = ''; // Continue without grid lines
        }

        // 2. Axes lines with validation
        let axesLines = '';
        try {
            axesLines = flavors.map((_, i) => {
                const p = getPoint(100, i);
                const coords = p.split(',');
                const x2 = parseFloat(coords[0]);
                const y2 = parseFloat(coords[1]);
                
                if (isNaN(x2) || isNaN(y2)) {
                    throw new Error('Invalid axis coordinates');
                }
                
                return `<line x1="${center}" y1="${center}" x2="${x2}" y2="${y2}" stroke="#d1d5db" stroke-width="1" vector-effect="non-scaling-stroke"/>`;
            }).join('');
        } catch (axesError) {
            console.warn('Axes generation failed:', axesError);
            axesLines = ''; // Continue without axes
        }

        // 3. Data polygon with validation
        let dataPolygon = '';
        try {
            const dataPoints = flavors.map((flavor, i) => {
                // Ensure flavor value is valid
                const value = Math.max(0, Math.min(100, flavor.value || 0));
                return getPoint(value, i);
            }).join(' ');
            dataPolygon = `<polygon points="${dataPoints}" fill="rgba(34, 197, 94, 0.5)" stroke="#16a34a" stroke-width="2" vector-effect="non-scaling-stroke"/>`;
        } catch (polygonError) {
            console.warn('Data polygon generation failed:', polygonError);
            // Create a simple circle as fallback
            dataPolygon = `<circle cx="${center}" cy="${center}" r="30" fill="rgba(34, 197, 94, 0.5)" stroke="#16a34a" stroke-width="2"/>`;
        }

        // 4. Labels with improved positioning
        let labels = '';
        try {
            labels = flavors.map((flavor, i) => {
                const p = getPoint(140, i); // Labels positioned at 140% for better spacing
                const coords = p.split(',');
                const x = parseFloat(coords[0]);
                const y = parseFloat(coords[1]);
                
                if (isNaN(x) || isNaN(y)) {
                    throw new Error('Invalid label coordinates');
                }
                
                let textAnchor = "middle";
                if (x < center - 15) textAnchor = "end";
                if (x > center + 15) textAnchor = "start";
                
                // Sanitize flavor name for SVG
                const safeName = (flavor.name || 'Unknown').replace(/[<>&"']/g, '');
                
                return `<text x="${x}" y="${y}" dy="0.3em" text-anchor="${textAnchor}" font-size="12" fill="#4b5563" font-family="system-ui, -apple-system, sans-serif">${safeName}</text>`;
            }).join('');
        } catch (labelError) {
            console.warn('Labels generation failed:', labelError);
            // Simple fallback labels
            labels = flavors.map((flavor, i) => 
                `<text x="${center}" y="${20 + i * 15}" text-anchor="middle" font-size="10" fill="#4b5563">${(flavor.name || 'Unknown').replace(/[<>&"']/g, '')}</text>`
            ).join('');
        }

        // Create SVG with namespace and enhanced compatibility
        const svgContent = `
            <svg width="100%" height="auto" viewBox="0 0 ${size} ${size}" 
                 xmlns="http://www.w3.org/2000/svg" 
                 style="max-width: 100%; height: auto; display: block;"
                 preserveAspectRatio="xMidYMid meet">
                ${gridLines}
                ${axesLines}
                ${labels}
                ${dataPolygon}
            </svg>
        `;

        // Test if the SVG can be parsed (additional safety check for iOS)
        if (typeof DOMParser !== 'undefined') {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgContent, 'image/svg+xml');
            const errorNode = doc.querySelector('parsererror');
            if (errorNode) {
                throw new Error('SVG parsing failed');
            }
        }

        return svgContent;

    } catch (error) {
        console.warn('Radar chart creation failed entirely:', error);
        // Return a basic visual fallback that should work on all devices
        throw error; // Re-throw to trigger fallback in calling function
    }
}

function positionThumbLabel(slider) {
    const label = document.getElementById(slider.id + 'Val');
    if (!label) {
        console.log('Label element not found for slider:', slider.id);
        return;
    }

    const min = parseFloat(slider.min);
    const max = parseFloat(slider.max);
    const val = parseFloat(slider.value);

    const thumbWidth = 16; // An approximation of the thumb width
    const trackWidth = slider.offsetWidth;
    const percent = (val - min) / (max - min);

    // Calculate the position of the thumb's center.
    // This positions the label's anchor point (center due to transform)
    // over the thumb's center.
    const thumbCenter = percent * (trackWidth - thumbWidth) + (thumbWidth / 2);

    label.style.left = `${thumbCenter}px`;
    label.style.display = 'block';
    label.style.visibility = 'visible';
    label.style.opacity = '1';
    
    let valueText;
    if (slider.name === 'priceRange') {
      valueText = '$' + (val * 0.25).toFixed(2);
    } else {
      valueText = val;
    }
    label.innerHTML = valueText;
    slider.setAttribute('aria-valuetext', valueText);
}

function updateTrackFill(slider) {
    const min = slider.min;
    const max = slider.max;
    const val = slider.value;
    const percentage = ((val - min) / (max - min)) * 100;
    slider.style.background = `linear-gradient(to right, #22c55e ${percentage}%, #e2e8f0 ${percentage}%)`;
}

function animateSlider(slider, toValue, duration = 400) {
    const fromValue = parseFloat(slider.value);
    const start = performance.now();

    function frame(currentTime) {
        const elapsed = currentTime - start;
        const progress = Math.min(elapsed / duration, 1);
        const easeOutQuad = t => t * (2 - t); // Easing function
        const easedProgress = easeOutQuad(progress);

        const currentValue = fromValue + (toValue - fromValue) * easedProgress;

        slider.value = currentValue;
        positionThumbLabel(slider);
        updateTrackFill(slider);

        if (progress < 1) {
            requestAnimationFrame(frame);
        } else {
            // Ensure final values are exact
            slider.value = toValue;
            positionThumbLabel(slider);
            updateTrackFill(slider);
            answers[slider.name] = toValue; // Make sure the final answer is stored
        }
    }
    requestAnimationFrame(frame);
}

// Helper functions for enhanced slider touch handling
function updateSliderFromTouch(slider, touch) {
  const rect = slider.getBoundingClientRect();
  const x = touch.clientX - rect.left;
  const width = rect.width;
  
  // Calculate percentage (0-1)
  let percentage = Math.max(0, Math.min(1, x / width));
  
  // Convert to slider value
  const min = parseFloat(slider.min);
  const max = parseFloat(slider.max);
  const value = min + (max - min) * percentage;
  
  // Update slider
  slider.value = value;
  updateTrackFill(slider);
  positionThumbLabel(slider); // Update the tooltip label
  answers[slider.name] = value;
}

function updateSliderFromMouse(slider, event) {
  const rect = slider.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const width = rect.width;
  
  // Calculate percentage (0-1)
  let percentage = Math.max(0, Math.min(1, x / width));
  
  // Convert to slider value
  const min = parseFloat(slider.min);
  const max = parseFloat(slider.max);
  const value = min + (max - min) * percentage;
  
  // Update slider
  slider.value = value;
  updateTrackFill(slider);
  positionThumbLabel(slider); // Update the tooltip label
  answers[slider.name] = value;
}

// Function to find the closest slider to a touch/mouse position
function findClosestSlider(x, y) {
  const sliders = document.querySelectorAll('input[type="range"]');
  let closestSlider = null;
  let closestDistance = Infinity;
  
  sliders.forEach(slider => {
    const rect = slider.getBoundingClientRect();
    
    // Check if the point is within the slider's vertical bounds (with some tolerance)
    const verticalTolerance = 50; // 50px tolerance above and below slider
    if (y >= rect.top - verticalTolerance && y <= rect.bottom + verticalTolerance) {
      // Calculate horizontal distance to slider center
      const sliderCenterX = rect.left + rect.width / 2;
      const distance = Math.abs(x - sliderCenterX);
      
      if (distance < closestDistance) {
        closestDistance = distance;
        closestSlider = slider;
      }
    }
  });
  
  return closestSlider;
}

// Function to check if touch is on navigation buttons
function isOnNavigationButton(x, y) {
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  
  if (prevBtn) {
    const prevRect = prevBtn.getBoundingClientRect();
    if (x >= prevRect.left && x <= prevRect.right && y >= prevRect.top && y <= prevRect.bottom) {
      return true;
    }
  }
  
  if (nextBtn) {
    const nextRect = nextBtn.getBoundingClientRect();
    if (x >= nextRect.left && x <= nextRect.right && y >= nextRect.top && y <= nextRect.bottom) {
      return true;
    }
  }
  
  return false;
}

function renderQuestion(idx){
  const q = quizData[idx];
  quizCard.innerHTML='';
  if(!q) return;

  const questionTitle = `<h3 class="text-xl font-semibold mb-4 text-center">${q.label}</h3>`;

  /* RADIO */
  if(q.type==='radio'){
    const subText = q.name === 'cupsPerDay' ? '<p class="text-sm text-gray-600 text-center mb-4">This helps us calculate your bi-weekly supply and pricing.</p>' : '';
    quizCard.innerHTML=`
      <div class="w-full max-w-md mx-auto">
        <h3 class="text-lg font-semibold mb-3 text-center">${q.label}</h3>
        ${subText}
        <div class="question-body">
          <div class="flex flex-wrap justify-center gap-2 pill-input">
            ${q.options.map(opt=>{
              const isObject = typeof opt === 'object';
              const value = isObject ? opt.value : opt;
              const text = isObject ? opt.text : opt;
              return `<label><input type="radio" name="${q.name}" value="${value}">
                <span class="text-sm px-3 py-1">${text}</span>
              </label>`;
            }).join('')}
          </div>
        </div>
      </div>`;
  }

  /* RANGE */
  else if(q.type==='range'){
    const defaultValue = answers[q.name] ?? q.min;
    const initialValue = q.min;
    let initialValueText;
    if (q.name === 'priceRange') {
      initialValueText = '$' + (parseFloat(initialValue) * 0.25).toFixed(2);
    } else {
      initialValueText = initialValue;
    }

    const subText = q.name === 'priceRange' ? '<p class="text-sm text-gray-600 text-center mb-4">The AI will make the best coffee for you within your budget.</p>' : '';
    quizCard.innerHTML=`
      <div class="w-full max-w-md mx-auto">
        <h3 id="${q.name}-label" class="text-lg font-semibold mb-3 text-center">${q.label}</h3>
        ${subText}
        <div class="question-body">
          <div class="flex items-end gap-x-3 w-full px-2">
            <span class="text-xs text-gray-500 mb-2">${q.left||''}</span>
            <div class="relative flex-grow h-16">
            <input type="range" id="${q.name}" name="${q.name}" min="${q.min}" max="${q.max}" step="${q.step}" value="${initialValue}" class="w-full standard-slider absolute bottom-0" style="margin: 0; padding: 0;" aria-labelledby="${q.name}-label" aria-valuenow="${initialValue}" aria-valuetext="${initialValueText}">
            <output for="${q.name}" id="${q.name}Val" class="output-bubble absolute pointer-events-none bg-[#16a34a] text-white text-xs font-semibold px-2 py-1 rounded shadow-lg" style="bottom: 2.5rem; left: 0px; z-index: 50; transform: translateX(-50%);">
                ${initialValueText}
            </output>
            </div>
            <span class="text-xs text-gray-500 mb-2">${q.right||''}</span>
          </div>
        </div>
      </div>`;
    const sliderEl = document.getElementById(q.name);

    // Set initial state
    updateTrackFill(sliderEl);
    positionThumbLabel(sliderEl);

    // Animate to default position
    setTimeout(() => {
        animateSlider(sliderEl, defaultValue);
    }, 150); // A short delay to allow for rendering
    
    // Enhanced touch handling for regular range sliders
    let isDragging = false;
    
    sliderEl.addEventListener('touchstart', function(e) {
      e.preventDefault();
      isDragging = true;
      const touch = e.touches[0];
      updateSliderFromTouch(this, touch);
    });
    
    sliderEl.addEventListener('touchmove', function(e) {
      e.preventDefault();
      if (isDragging) {
        const touch = e.touches[0];
        updateSliderFromTouch(this, touch);
      }
    });
    
    sliderEl.addEventListener('touchend', function(e) {
      isDragging = false;
    });
    
    // Also handle mouse events for desktop
    sliderEl.addEventListener('mousedown', function(e) {
      isDragging = true;
      updateSliderFromMouse(this, e);
    });
    
    document.addEventListener('mousemove', function(e) {
      if (isDragging) {
        const activeSlider = document.querySelector('input[type="range"]:focus');
        if (activeSlider) {
          updateSliderFromMouse(activeSlider, e);
        }
      }
    });
    
    document.addEventListener('mouseup', function() {
      isDragging = false;
    });
  }

  /* MULTI‑RANGE */
  else if(q.type==='multi-range'){
    quizCard.innerHTML=`
      <div class="w-full max-w-md mx-auto">
        <h3 class="text-lg font-semibold mb-3 text-center">${q.label}</h3>
        <div class="question-body multi-range-container">
          <div class="space-y-3 w-full">${q.names.map((n,i)=>`
            <div>
              <p class="mb-1 text-xs text-center">${q.flavors[i]}</p>
              <div class="slider-with-end-labels">
                <input type="range" id="${n}" name="${n}" min="${q.min}" max="${q.max}" step="${q.step}" value="${answers[n]??50}" class="w-full accent-[#22c55e]">
                <div class="relative">
                  <span class="absolute left-0 text-xs text-gray-500 mt-1">Dislike</span>
                  <span class="absolute right-0 text-xs text-gray-500 mt-1">Love it</span>
                </div>
              </div>
            </div>`).join('')}</div>
        </div>
      </div>`;
    
    // Single slider at a time functionality
    let activeSlider = null;
    let allSliders = [];
    
    // Set up track fill for all flavor sliders
    q.names.forEach(name => {
      const slider = document.getElementById(name);
      if (slider) {
        allSliders.push(slider);
        updateTrackFill(slider);
        
        // Enhanced event listeners for smooth slider interaction
        slider.addEventListener('input', function() {
          updateTrackFill(this);
        });
        
        // Function to disable all sliders except the active one
        function disableOtherSliders(activeSlider) {
          allSliders.forEach(s => {
            if (s !== activeSlider) {
              s.style.pointerEvents = 'none';
              s.style.opacity = '0.5';
            }
          });
        }
        
        // Function to enable all sliders
        function enableAllSliders() {
          allSliders.forEach(s => {
            s.style.pointerEvents = 'auto';
            s.style.opacity = '1';
          });
        }
        
        // Enhanced touch handling for mobile
        let isDragging = false;
        
        slider.addEventListener('touchstart', function(e) {
          e.preventDefault();
          if (activeSlider && activeSlider !== this) {
            return; // Only allow interaction with the active slider
          }
          
          isDragging = true;
          activeSlider = this;
          disableOtherSliders(this);
          
          const touch = e.touches[0];
          updateSliderFromTouch(this, touch);
        });
        
        slider.addEventListener('touchmove', function(e) {
          e.preventDefault();
          if (isDragging && activeSlider === this) {
            const touch = e.touches[0];
            updateSliderFromTouch(this, touch);
          }
        });
        
        slider.addEventListener('touchend', function(e) {
          isDragging = false;
          activeSlider = null;
          enableAllSliders();
        });
        
        // Also handle mouse events for desktop
        slider.addEventListener('mousedown', function(e) {
          if (activeSlider && activeSlider !== this) {
            return; // Only allow interaction with the active slider
          }
          
          isDragging = true;
          activeSlider = this;
          disableOtherSliders(this);
          updateSliderFromMouse(this, e);
        });
        
        document.addEventListener('mousemove', function(e) {
          if (isDragging && activeSlider) {
            updateSliderFromMouse(activeSlider, e);
          }
        });
        
        document.addEventListener('mouseup', function() {
          isDragging = false;
          activeSlider = null;
          enableAllSliders();
        });
      }
    });
  }

  /* CHECKBOX */
  else if(q.type==='checkbox'){
    quizCard.innerHTML=`
      <div class="w-full max-w-md mx-auto">
        <h3 class="text-lg font-semibold mb-3 text-center">${q.label}</h3>
        <div class="question-body">
          <div class="flex flex-wrap justify-center gap-2 pill-input">
            ${q.options.map((opt,i)=>`
              <label><input type="checkbox" name="${q.names[i]}" ${answers[q.names[i]]?'checked':''}>
                <span class="text-sm px-3 py-1">${opt}</span></label>`).join('')}
          </div>
        </div>
      </div>`;
  }

  /* TEXT */
  else if(q.type==='text'){
    // Check if this is the blend name question
    if(q.name === 'blendName') {
      // Hide the "Train your coffee AI" heading on the blend naming page
      const quizTitle = document.getElementById('quizTitle');
      if (quizTitle) {
        quizTitle.classList.add('hidden');
      }
      /* ----------  A. establish an immediate skeleton  ---------- */
      quizCard.innerHTML = `
        <div class="w-full max-w-md mx-auto custom-roast-content animate-pulse">
          <div class="h-4 bg-gray-200 rounded w-3/4 mx-auto mb-4"></div>
          <div class="h-32 bg-gray-200 rounded mx-auto mb-4"></div>
          <div class="h-8 bg-gray-200 rounded w-1/2 mx-auto"></div>
        </div>`;

      /* ----------  B. build the real content off‑thread  ---------- */
      requestAnimationFrame(() => {

        /* 1. Resolve all data you need – never trust globals directly */
        const defaults = {
          personality: 'Enjoy some variety',
          roastLevel: 'medium',
          brewMethod: 'drip',
          tasteBalance: 'Sweet & Smooth',
          flavorNutty: '50',
          flavorFruity: '50',
          flavorFloral: '50',
          flavorSmoky: '50',
          blendName: ''
        };
        const safeAnswers = { ...defaults, ...answers };

        /* 2. Compute flavours, notes, etc. inside tryOrFallback       */
        const flavours = tryOrFallback(() => [
          { name:'Nutty',  value: +safeAnswers.flavorNutty  || 50 },
          { name:'Fruity', value: +safeAnswers.flavorFruity || 50 },
          { name:'Floral', value: +safeAnswers.flavorFloral || 50 },
          { name:'Smoky',  value: +safeAnswers.flavorSmoky  || 50 },
        ], []);

        const radarSVG = tryOrFallback(() => createRadarChart(flavours), `
          <div class="flavor-profile-fallback flex flex-col gap-1 bg-gray-50 rounded-lg p-4 border">
            <h5 class="text-xs font-semibold text-gray-600 mb-2 text-center">Flavor Profile</h5>
            ${flavours.map(f => `<div class="mb-2">
                 <div class="flex justify-between text-xs text-gray-600 mb-1">
                   <span>${f.name}</span><span>${f.value}%</span>
                 </div>
                 <div class="w-full bg-gray-200 h-2 rounded-full">
                   <div class="bg-green-500 h-2 rounded-full" style="width:${f.value}%"></div>
                 </div>
               </div>`).join('')}
          </div>`);

        const suggestions = tryOrFallback(() =>
            generateBlendNameSuggestions(safeAnswers, flavours, ''), 
          ['Custom Blend','Perfect Balance','Personal Pick']);

        /* 3. Paint the final markup – always within one innerHTML     */
        quizCard.innerHTML = `
          <div class="w-full max-w-md mx-auto custom-roast-content">
            <h4 class="text-sm font-bold text-center mb-2 text-gray-700">
              ${safeAnswers.personality === 'Bring on the funk!' ? 'The Explorer' :
                safeAnswers.personality === 'Stick to classics'   ? 'The Connoisseur' :
                safeAnswers.personality === 'Enjoy some variety'  ? 'The Artisan'     :
                'Your custom blend'}
            </h4>

            <div class="flex justify-center mb-3" style="min-height:150px">${radarSVG}</div>

            <div class="text-center">
              <label for="blendName" class="block text-sm font-medium mb-1">
                Name your blend
              </label>
              <input id="blendName" name="blendName" maxlength="25" autocapitalize="words"
                class="w-full max-w-xs mx-auto border border-gray-300 rounded px-2 py-1.5
                       focus:outline-none focus:ring-2 focus:ring-green-200 text-sm"
                placeholder="e.g. Perfect Balance" value="${safeAnswers.blendName||''}">

              <p class="text-xs text-gray-500 mt-1 text-center">Or tap a suggestion:</p>
              <div id="blendSuggestions" class="flex flex-wrap justify-center gap-1 mt-1">
                ${suggestions.map(s => `<button type="button"
                     class="suggestion-chip px-2 py-1 bg-gray-100 border border-gray-300
                            rounded-full text-xs hover:bg-green-500 hover:text-white transition-colors"
                     onclick="document.getElementById('blendName').value='${s}';
                              answers.blendName='${s}';">${s}</button>`).join('')}
              </div>
            </div>

            <p class="text-xs text-gray-600 mt-3 text-center px-2">
              A ${safeAnswers.roastLevel.toLowerCase()} roast highlighting
              ${flavours.sort((a,b)=>b.value-a.value).slice(0,2).map(f=>f.name).join(' & ').toLowerCase()}
              notes – perfect for your ${safeAnswers.brewMethod.toLowerCase()}.
            </p>
          </div>`;


      });
      return;                    // prevent the "regular text" fallback below
    } else {
      // Regular text question
    quizCard.innerHTML=`
      <div class="w-full max-w-md mx-auto">
        <h3 class="text-lg font-semibold mb-3 text-center">${q.label}</h3>
        <div class="question-body">
          <input type="text" id="${q.name}" name="${q.name}" class="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-green-200" value="${answers[q.name]||''}">
        </div>
      </div>`;
    }
  }

  /* Listeners for newly added controls */
  quizCard.querySelectorAll('input,textarea').forEach(el=>{
    el.addEventListener('input', e=>{
      if(el.type==='checkbox'){answers[el.name]=el.checked}
      else{answers[el.name]=el.value}
      if(el.type === 'range') {
        positionThumbLabel(el);
        updateTrackFill(el);
      }
      
      // Track question answered
      const questionData = quizData[current];
      if (questionData) {
        trackGA4('question_answered', { 
          question: questionData.name || questionData.names?.join('_'), 
          answer: el.type === 'checkbox' ? el.checked : el.value,
          questionType: questionData.type,
          questionIndex: current
        });
      }
    });
    
    // Enhanced interaction for all range sliders - no visual changes
    if(el.type === 'range') {
      // Prevent page scroll during slider interaction on touch devices
      el.addEventListener('touchstart', function(e) {
        // Allow the slider to work but prevent page scroll
        e.stopPropagation();
      }, { passive: true });
      
      el.addEventListener('touchmove', function(e) {
        // Prevent page scroll during drag
        e.stopPropagation();
      }, { passive: true });
    }
    
    // Add click event for radio buttons to handle all selections including defaults
    if(el.type==='radio'){
      el.addEventListener('click', e=>{
        answers[el.name]=el.value;
        
        // Track radio button selection
        const questionData = quizData[current];
        if (questionData) {
          trackGA4('question_answered', { 
            question: questionData.name, 
            answer: el.value,
            questionType: questionData.type,
            questionIndex: current
          });
        }
        
        // Add delay to show the animation before advancing
        setTimeout(() => {
        autoNext();
        }, 300); // 300ms delay to show the green selection animation
      });
    }
    
    // Add keyboard events for text inputs and textareas
    if(el.type==='textarea' || el.tagName.toLowerCase() === 'textarea'){
      el.addEventListener('keydown', e=>{
        if(e.key === 'Enter' && !e.shiftKey){
          e.preventDefault();
          
          // Blur the textarea to close mobile keyboard
          el.blur();
          
          // Add visual feedback - briefly highlight the input
          const originalBorder = el.style.border;
          el.style.border = '2px solid #22c55e';
          el.style.transition = 'border-color 0.3s ease';
          
          // Longer delay to allow keyboard to close and user to understand what happened
          setTimeout(() => {
            // Reset border style
            el.style.border = originalBorder;
            autoNext();
          }, 800); // 800ms delay for graceful keyboard close and user comprehension
        }
        // Shift+Enter allows new line (default behavior)
      });
    }
    
    // Add keyboard events for text inputs (Enter to continue)
    if(el.type==='text'){
      el.addEventListener('keydown', e=>{
        if(e.key === 'Enter'){
          e.preventDefault();
          
          // Blur the input to close mobile keyboard
          el.blur();
          
          // Add visual feedback - briefly highlight the input
          const originalBorder = el.style.border;
          el.style.border = '2px solid #22c55e';
          el.style.transition = 'border-color 0.3s ease';
          
          // Longer delay to allow keyboard to close and user to understand what happened
          setTimeout(() => {
            // Reset border style
            el.style.border = originalBorder;
            autoNext();
          }, 800); // 800ms delay for graceful keyboard close and user comprehension
        }
      });
    }
  });
  
  // Auto-focus the first text input or textarea
  const firstTextInput = quizCard.querySelector('input[type="text"], textarea');
  if (firstTextInput) {
    // Small delay to ensure the element is fully rendered
    setTimeout(() => {
      firstTextInput.focus();
    }, 100);
  }
}



/*------------------------------------------------------------------
  NAVIGATION
------------------------------------------------------------------*/
function autoNext(){
  if(current<quizData.length){
    // If this is the first selection (moving from question 0 to 1), activate full-screen mode
    if(current === 0) {
        // Track quiz start
  trackGA4('quiz_start', { 
    userId: userId, 
    device: /Mobile|Android|iPhone|iPad/.test(navigator.userAgent) ? 'mobile' : 'desktop',
    question_count: quizData.length
  });
      
      document.body.classList.add('quiz-fullscreen');
      document.body.classList.add('quiz-active'); // Immediately apply pull-to-refresh protection
      document.getElementById('quiz').classList.add('quiz-fullscreen');
      document.getElementById('quizEscape').classList.remove('hidden');
      
      // Force a layout recalculation to ensure iOS respects the new CSS immediately
      document.body.offsetHeight;
    }
    current++;
    updateUI();
  }
}
function updateUI(){
  // Refresh button references to avoid stale nodes after replacement
  prevBtn = document.getElementById('prevBtn');
  submitBtn = document.getElementById('submitBtn');
  if (current >= quizData.length && !isLoading) {
    return;
  }
  
  // Show/hide the quiz title based on current question
  const quizTitle = document.getElementById('quizTitle');
  if (quizTitle) {
    if (current === quizData.length - 1 && quizData[current] && quizData[current].name === 'blendName') {
      // Hide title on blend naming page
      quizTitle.classList.add('hidden');
    } else {
      // Show title for all other questions
      quizTitle.classList.remove('hidden');
    }
  }
  
  renderQuestion(current);

  // Calculate progress
  if (current === 0) {
    progressBar.style.width = '0%';
  } else {
    const progress = current / quizData.length;
    
    // Ensure progress reaches 100% on the last question
    if (current === quizData.length - 1) {
      progressBar.style.width = '100%';
      
      // After 3 seconds, fade out the progress bar
      setTimeout(() => {
        const progressContainer = progressBar.parentElement;
        progressContainer.classList.add('progress-fade-out');
      }, 3000);
    } else {
      progressBar.style.width = (progress * 100) + '%';
    }
  }

  // Update navigation button visibility
  const buttonContainer = document.getElementById('buttonContainer');
  
  if (current === 0) {
    prevBtn.classList.add('hidden');
    prevBtn.style.display = 'none';
    submitBtn.classList.add('hidden');
    submitBtn.style.display = 'none';
    buttonContainer.style.display = 'none'; // Hide the entire container
  } else {
    prevBtn.classList.remove('hidden');
    prevBtn.style.display = 'inline-block';
    prevBtn.disabled = false;
    submitBtn.classList.remove('hidden');
    submitBtn.style.display = 'inline-block';
    buttonContainer.style.display = 'flex'; // Show the container
    
    // Disable submit button initially to prevent accidental early submission
    // (visually appears normal, but clicks are ignored)
    submitBtn.disabled = true;
    
    // Clear any existing timeout to prevent overlapping delays
    if (window.submitBtnTimeout) {
      clearTimeout(window.submitBtnTimeout);
    }
    
    // Enable submit button after 1.5 seconds (or immediately for checkout)
    const delay = (current === quizData.length - 1) ? 0 : 1500;
    window.submitBtnTimeout = setTimeout(() => {
      submitBtn.disabled = false;
      window.submitBtnTimeout = null; // Clear reference
    }, delay);
  }

  if (current === quizData.length - 1) {
    submitBtn.textContent = 'Checkout';
    submitBtn.disabled = false;
    submitBtn.removeAttribute('disabled');
    submitBtn.style.pointerEvents = 'auto';
    submitBtn.style.cursor = 'pointer';
    
    // Clear any pending timeout
    if (window.submitBtnTimeout) {
      clearTimeout(window.submitBtnTimeout);
      window.submitBtnTimeout = null;
    }
    
    // BRUTE FORCE APPROACH - Add multiple handlers to make sure SOMETHING works
    
    // Method 1: Direct onclick (immediate)
    submitBtn.onclick = function() {
      console.log('CHECKOUT ONCLICK FIRED - METHOD 1');
      handleCheckout();
    };
    
    // Method 2: addEventListener (immediate)
    submitBtn.addEventListener('click', function(e) {
      console.log('CHECKOUT CLICK EVENT FIRED - METHOD 2');
      e.preventDefault();
      e.stopPropagation();
      handleCheckout();
    }, { passive: false });
    
    // Method 3: Touch events for mobile (immediate)
    submitBtn.addEventListener('touchend', function(e) {
      console.log('CHECKOUT TOUCH EVENT FIRED - METHOD 3');
      e.preventDefault();
      e.stopPropagation();
      handleCheckout();
    }, { passive: false });
    
    // Method 4: Replace button after a delay (backup)
    setTimeout(() => {
      const oldBtn = document.getElementById('submitBtn');
      if (oldBtn && oldBtn.textContent === 'Checkout') {
        console.log('REPLACING CHECKOUT BUTTON - METHOD 4');
        const newBtn = document.createElement('button');
        newBtn.id = 'submitBtn';
        newBtn.className = oldBtn.className;
        newBtn.textContent = 'Checkout';
        newBtn.type = 'button';
        newBtn.disabled = false;
        newBtn.style.pointerEvents = 'auto';
        newBtn.style.cursor = 'pointer';
        newBtn.onclick = function() {
          console.log('REPLACED BUTTON CLICKED - METHOD 4');
          // Force enable button before calling handleCheckout
          newBtn.disabled = false;
          newBtn.removeAttribute('disabled');
          handleCheckout();
        };
        oldBtn.parentNode.replaceChild(newBtn, oldBtn);
      }
    }, 100);
    
    console.log('Checkout button armed with 4 different methods');
  } else {
    submitBtn.textContent = 'Next';
  }
}

/* CONSOLIDATED "PREVIOUS" BUTTON LOGIC */
document.addEventListener('click', function(e) {
  const prevBtn = e.target.closest('#prevBtn');
  if (prevBtn) {
    const submitBtn = document.getElementById('submitBtn');
    const isCheckoutPage = submitBtn && submitBtn.textContent === 'Buy Now';

    if (isCheckoutPage) {
      // Go back to the last question of the quiz
      current = quizData.length - 1;
      // Reset submit button to remove stale listeners
      (function(){
        const staleBtn=document.getElementById('submitBtn');
        if(staleBtn){
          const cleanBtn=staleBtn.cloneNode(false);
          cleanBtn.id='submitBtn';
          staleBtn.parentNode.replaceChild(cleanBtn, staleBtn);
        }
      })();
      updateUI();
    } else if (current > 0) {
      // Regular quiz navigation
      if (current === quizData.length - 1) {
        const progressBar = document.getElementById('progressBar');
        const progressContainer = progressBar.parentElement;
        progressContainer.classList.remove('progress-fade-out');
      }
      current--;
      updateUI();
    }
  }
});

updateUI(); // initial render

// Test button functionality on page load
console.log('Page loaded - Testing button functionality');
console.log('Submit button:', document.getElementById('submitBtn'));
console.log('Previous button:', document.getElementById('prevBtn'));

// Add a simple test to verify click events work
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM loaded - Testing click events');
  
  // Test if basic click events work
  document.addEventListener('click', function(e) {
    console.log('Document clicked:', e.target.tagName, e.target.id);
  });
  
  // Mobile-specific button monitoring
  setInterval(function() {
    const submitBtn = document.getElementById('submitBtn');
    if (submitBtn && /Checkout|Buy Now/.test(submitBtn.textContent.trim())) {
      if (submitBtn.disabled) {
        console.log('Mobile monitor - Re-enabling disabled button:', submitBtn.textContent.trim());
        submitBtn.disabled = false;
        submitBtn.removeAttribute('disabled');
        submitBtn.style.pointerEvents = 'auto';
        submitBtn.style.cursor = 'pointer';
      }
    }
  }, 1000); // Check every second
});

// Hero button gentle scroll
document.getElementById('heroButton').addEventListener('click', function() {
  // Track quiz initiation
  trackGA4('quiz_initiated', { 
    userId: userId,
    device: /Mobile|Android|iPhone|iPad/.test(navigator.userAgent) ? 'mobile' : 'desktop',
    source: 'hero_button'
  });
  
  const quizSection = document.getElementById('quiz');
  quizSection.scrollIntoView({ 
    behavior: 'smooth',
    block: 'start'
  });
});

// Escape functionality - Exit fullscreen but maintain quiz progress
document.getElementById('quizEscape').addEventListener('click', function() {
  // Track quiz exit
  trackGA4('quiz_exit', { 
    lastStep: current,
    totalQuestions: quizData.length,
    progress: Math.round((current / quizData.length) * 100)
  });
  
  // Clear any pending submit button timeout
  if (window.submitBtnTimeout) {
    clearTimeout(window.submitBtnTimeout);
    window.submitBtnTimeout = null;
  }
  
  // Remove full-screen mode (but keep quiz progress)
  document.body.classList.remove('quiz-fullscreen');
  document.getElementById('quiz').classList.remove('quiz-fullscreen');
  document.getElementById('quizEscape').classList.add('hidden');
  
  // Remove progress bar fade-out animation but maintain progress
  const progressBar = document.getElementById('progressBar');
  const progressContainer = progressBar.parentElement;
  progressContainer.classList.remove('progress-fade-out');
  
  // Show the quiz title again when escaping
  const quizTitle = document.getElementById('quizTitle');
  if (quizTitle) {
    quizTitle.classList.remove('hidden');
  }
  
  // Hide buttons if we're back to the first question (early exit)
  if (current === 0) {
    const buttonContainer = document.getElementById('buttonContainer');
    const prevBtn = document.getElementById('prevBtn');
    const submitBtn = document.getElementById('submitBtn');
    
    if (buttonContainer) buttonContainer.style.display = 'none';
    if (prevBtn) {
      prevBtn.classList.add('hidden');
      prevBtn.style.display = 'none';
    }
    if (submitBtn) {
      submitBtn.classList.add('hidden'); 
      submitBtn.style.display = 'none';
    }
  }
  
  // Update UI to show current question with correct progress and button text
  updateUI();
  
  // Scroll back to quiz section
  document.getElementById('quiz').scrollIntoView({ behavior: 'smooth' });
});




/*------------------------------------------------------------------
  BACK‑END COMM
------------------------------------------------------------------*/
function submitToSheet(tab, formData){
  console.log('submitToSheet called with tab:', tab); // Debug log
  console.log('FormData entries:'); // Debug log
  for (let [key, value] of formData.entries()) {
    console.log(key, value); // Debug log
  }
  
  return fetch(`${GAS_URL}?tab=${encodeURIComponent(tab)}`,{
    method:'POST',
    mode:'cors',
    headers:{'Accept':'application/json'},
    body:formData
  })
  .then(r=>r.json())
  .then(result => {
    console.log('submitToSheet result:', result); // Debug log
    return result;
  })
  .catch((error) => {
    console.error('submitToSheet error:', error); // Debug log
    return {status:'ERR'};
  });
}

/* QUIZ SUBMIT -----------------------------------------------------*/
// Add click event listener for the submit button (for Next navigation only)
// NOTE: Checkout button gets its own direct onclick handler in updateUI()
submitBtn.addEventListener('click', function() {
  console.log('Submit button clicked, text:', submitBtn.textContent); // Debug log
  console.log('Current question:', current, 'Total questions:', quizData.length); // Debug log
  
  // Only handle Next navigation here
  if (submitBtn.textContent.trim() === 'Next') {
    console.log('Regular navigation - moving to next question'); // Debug log
    current++;
    updateUI();
  }
  // Buy Now is handled by direct binding in handleCheckout()
  else if (submitBtn.textContent.trim() === 'Buy Now') {
    console.log('Buy Now detected, calling handleContactSubmission'); // Debug log
    handleContactSubmission();
  }
  // Checkout gets its own direct handler - this shouldn't fire
  else if (submitBtn.textContent === 'Checkout') {
    console.log('OLD HANDLER - Checkout button clicked - this should not happen');
  }
});

// Add a more robust button click handler using event delegation
document.addEventListener('click', function(e) {
  // Check if the clicked element is the submit button using closest()
  const btn = e.target.closest('#submitBtn');
  if (btn) {
    console.log('Event delegation - Submit button clicked, text:', btn.textContent);
    console.log('Button disabled state:', btn.disabled);
    
    // If button is disabled, don't process the click
    if (btn.disabled) {
      console.log('Button is disabled, ignoring click');
      return;
    }
    
    // Check if we're on the contact form (Buy Now mode)
    if (btn.textContent.trim() === 'Buy Now') {
      console.log('Event delegation - Buy Now detected, calling handleContactSubmission');
      e.preventDefault();
      e.stopPropagation();
      handleContactSubmission();
    }
    // Check if we're on the last question (Checkout mode) - handled by direct onclick
    else if (btn.textContent === 'Checkout') {
      console.log('Event delegation - Checkout detected, but handled by direct onclick - ignoring');
      e.preventDefault();
      e.stopPropagation();
      return; // Don't interfere with direct handler
    } else {
      console.log('Event delegation - Regular navigation - moving to next question');
      e.preventDefault();
      e.stopPropagation();
      current++;
      updateUI();
    }
  }
  

});

// Mobile touch handler removed - using direct binding approach instead

// Sanity test function for debugging button issues
window.testBuyNowButton = function() {
  const btn = document.getElementById('submitBtn');
  if (btn) {
    console.log('Button test - Text:', btn.textContent, 'Disabled:', btn.disabled, 'Display:', btn.style.display);
    btn.onclick = () => alert('Button click test - fires!');
    return 'Test function added. Tap the button to see if it responds.';
  } else {
    return 'Button not found!';
  }
};

// One-line sanity test for Checkout button
window.testCheckoutButton = function() {
  const btn = document.getElementById('submitBtn');
  if (btn) {
    console.log('=== CHECKOUT BUTTON TEST ===');
    console.log('Text:', btn.textContent);
    console.log('Disabled:', btn.disabled);
    console.log('Has onclick:', !!btn.onclick);
    btn.onclick = () => alert('TEST: Checkout button fires!');
    return 'Test added. Tap button to see if it responds.';
  }
  return 'Button not found!';
}; 

// EMERGENCY FIX - Run this in console if button still doesn't work
window.forceFixCheckoutButton = function() {
  const btn = document.getElementById('submitBtn');
  if (btn && btn.textContent === 'Checkout') {
    console.log('FORCE FIXING CHECKOUT BUTTON');
    
    // Remove all existing handlers
    btn.onclick = null;
    btn.replaceWith(btn.cloneNode(true));
    
    // Get the fresh button
    const freshBtn = document.getElementById('submitBtn');
    freshBtn.disabled = false;
    freshBtn.removeAttribute('disabled');
    freshBtn.style.pointerEvents = 'auto';
    freshBtn.style.cursor = 'pointer';
    
    freshBtn.onclick = function() {
      console.log('FORCE FIXED BUTTON CLICKED');
      // Ensure button stays enabled
      freshBtn.disabled = false;
      freshBtn.removeAttribute('disabled');
      handleCheckout();
    };
    
    freshBtn.addEventListener('click', function(e) {
      console.log('FORCE FIXED CLICK LISTENER');
      // Ensure button stays enabled
      freshBtn.disabled = false;
      freshBtn.removeAttribute('disabled');
      e.preventDefault();
      e.stopPropagation();
      handleCheckout();
    }, { passive: false });
    
    return 'Button force fixed. Try tapping now.';
  }
  return 'No checkout button found or wrong text';
};

// DEBUG: Mobile keyboard and button positioning
window.debugKeyboardPosition = function() {
  const nav = document.getElementById('buttonContainer');
  const submitBtn = document.getElementById('submitBtn');
  
  console.log('=== KEYBOARD & BUTTON DEBUG ===');
  console.log('Screen width:', window.innerWidth, 'px');
  console.log('Device type:', window.innerWidth >= 640 ? 'DESKTOP' : 'MOBILE');
  console.log('Button container:', nav ? 'FOUND' : 'NOT FOUND');
  console.log('Submit button:', submitBtn ? submitBtn.textContent : 'NOT FOUND');
  
  if (nav) {
    console.log('Button position style:', nav.style.position || 'CSS-DEFAULT');
    console.log('Button bottom:', nav.style.bottom || 'CSS-DEFAULT');
    console.log('Button transform:', nav.style.transform || 'CSS-DEFAULT');
    console.log('Button margin:', nav.style.margin || 'CSS-DEFAULT');
    
    // Get actual computed position
    const rect = nav.getBoundingClientRect();
    console.log('Actual button position:', {
      left: Math.round(rect.left),
      top: Math.round(rect.top),
      bottom: Math.round(window.innerHeight - rect.bottom),
      width: Math.round(rect.width)
    });
  }
  
  if (window.visualViewport && window.innerWidth < 640) {
    const vh = window.visualViewport.height;
    const vt = window.visualViewport.offsetTop;
    const wh = window.innerHeight;
    const keyboardHeight = Math.max(0, wh - vh - vt);
    
    console.log('Visual viewport height:', vh);
    console.log('Visual viewport top:', vt);
    console.log('Window height:', wh);
    console.log('Calculated keyboard height:', keyboardHeight);
    console.log('Keyboard state:', document.body.classList.contains('keyboard-open') ? 'OPEN' : 'CLOSED');
  } else if (window.innerWidth >= 640) {
    console.log('Desktop mode - consistent fixed positioning active');
  } else {
    console.log('Visual Viewport API: NOT AVAILABLE');
  }
  
  return 'Debug info logged above';
};

// TEST: Check button position consistency across questions
window.testButtonConsistency = function() {
  const nav = document.getElementById('buttonContainer');
  if (!nav) return 'Button container not found';
  
  let positions = [];
  let questionCount = 0;
  
  const checkPosition = () => {
    const rect = nav.getBoundingClientRect();
    const pos = {
      question: questionCount + 1,
      left: Math.round(rect.left),
      top: Math.round(rect.top),
      bottom: Math.round(window.innerHeight - rect.bottom)
    };
    positions.push(pos);
    console.log(`Question ${pos.question} - Button position:`, pos);
    
    if (questionCount > 0) {
      const prev = positions[questionCount - 1];
      const current = positions[questionCount];
      const moved = prev.left !== current.left || prev.top !== current.top || prev.bottom !== current.bottom;
      console.log(`Position changed from previous: ${moved ? 'YES ❌' : 'NO ✅'}`);
    }
    
    questionCount++;
  };
  
  // Check current position
  checkPosition();
  
  // Set up observer for future checks
  if (!window.buttonConsistencyObserver) {
    const observer = new MutationObserver(() => {
      setTimeout(checkPosition, 100); // Small delay for DOM updates
    });
    
    const quizCard = document.getElementById('quizCard');
    if (quizCard) {
      observer.observe(quizCard, { childList: true, subtree: true });
      window.buttonConsistencyObserver = observer;
    }
  }
  
  return 'Button position tracking started. Check console for updates.';
};

// TEST: Measure gap between quiz card and buttons
window.measureQuizLayout = function() {
  const quizCard = document.getElementById('quizCard');
  const buttonContainer = document.getElementById('buttonContainer');
  
  if (!quizCard || !buttonContainer) {
    return 'Quiz card or button container not found';
  }
  
  const cardRect = quizCard.getBoundingClientRect();
  const buttonRect = buttonContainer.getBoundingClientRect();
  
  const gap = buttonRect.top - cardRect.bottom;
  const screenHeight = window.innerHeight;
  const totalUsedHeight = cardRect.height + buttonRect.height + gap;
  const wastedSpace = screenHeight - totalUsedHeight;
  
  console.log('=== QUIZ LAYOUT MEASUREMENT ===');
  console.log('Screen height:', screenHeight, 'px');
  console.log('Quiz card height:', Math.round(cardRect.height), 'px');
  console.log('Button height:', Math.round(buttonRect.height), 'px');
  console.log('Gap between card and buttons:', Math.round(gap), 'px');
  console.log('Total used height:', Math.round(totalUsedHeight), 'px');
  console.log('Wasted space:', Math.round(wastedSpace), 'px');
  console.log('Space efficiency:', Math.round((totalUsedHeight / screenHeight) * 100) + '%');
  
  if (gap > 100) {
    console.log('⚠️  Gap is quite large - consider reducing for better UX');
  } else if (gap < 30) {
    console.log('⚠️  Gap might be too small - ensure no overlap');
  } else {
    console.log('✅ Gap looks good for user experience');
  }
  
  return {
    gap: Math.round(gap),
    efficiency: Math.round((totalUsedHeight / screenHeight) * 100)
  };
};

// Debug function to check button state
window.debugCheckoutButton = function() {
  const btn = document.getElementById('submitBtn');
  if (btn) {
    console.log('=== Checkout Button Debug ===');
    console.log('Text:', btn.textContent);
    console.log('Disabled:', btn.disabled);
    console.log('Display:', btn.style.display);
    console.log('Pointer Events:', btn.style.pointerEvents);
    console.log('Type:', btn.type);
    console.log('Event Listeners:', btn.onclick, btn.onpointerup);
    console.log('Current question:', current, 'Total questions:', quizData.length);
    return 'Debug info logged to console';
  } else {
    return 'Button not found!';
  }
};

async function handleCheckout() {
  const submitButton = document.getElementById('submitBtn');
  
  // Track checkout view
  trackGA4('checkout_view', { 
    budget: answers.priceRange,
    cupsPerDay: answers.cupsPerDay,
    roastLevel: answers.roastLevel,
    brewMethod: answers.brewMethod,
    blendName: answers.blendName || 'Custom Blend'
  });
  
  // --- UI Transition (Immediate) ---
  submitButton.disabled = true; // Prevent double-clicks
  errorMessage.classList.add('hidden');

  // Hide the quiz title and show the contact form.
  document.getElementById('quizTitle').classList.add('hidden');
  quizCard.classList.remove('hidden');
  // Calculate pricing
  const pricePerCup = answers.priceRange * 0.25;
  const cupsPerDay = parseInt(answers.cupsPerDay) || 1; // Convert string to number
  const cupsPerTwoWeeks = cupsPerDay * 14;
  const biweeklySubtotal = pricePerCup * cupsPerTwoWeeks;
  const shipping = 5.00;
  const totalBeforeRounding = biweeklySubtotal + shipping;
  const total = Math.floor(totalBeforeRounding) + 0.95; // Round down to nearest 95 cent spot
  const blendName = answers.blendName || 'Your custom blend';

  quizCard.innerHTML = `
    <div class="w-full max-w-md mx-auto">
      <h3 class="text-base font-semibold mb-3 text-center">Checkout</h3>
      
      <!-- Compact Order Summary -->
      <div class="bg-gray-50 rounded-lg p-3 mb-3">
        <div class="flex items-center justify-between mb-2">
          <div class="flex items-center space-x-2">
            <div class="w-8 h-8 bg-[#22c55e] rounded flex items-center justify-center">
              <svg class="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 20 20">
                <path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z"/>
              </svg>
            </div>
            <div>
              <p class="font-medium text-xs text-gray-800">${blendName}</p>
              <p class="text-xs text-gray-500">${pricePerCup.toLocaleString('en-US', { style: 'currency', currency: 'USD' })} per cup × ${cupsPerTwoWeeks} cups</p>
              <p class="text-xs text-gray-500">Bi-weekly subscription</p>
            </div>
          </div>
          <div class="text-right">
            <p class="font-semibold text-sm text-gray-800">${total.toLocaleString('en-US', { style: 'currency', currency: 'USD' })}</p>
            <p class="text-xs text-gray-500">incl. shipping</p>
          </div>
        </div>
      </div>

      <!-- Contact Form -->
      <div class="space-y-2">
        <h4 class="font-semibold text-xs mb-2 text-gray-800">Contact Information</h4>
        <div>
          <label class="block font-medium mb-1 text-xs" for="contactName">Full Name</label>
          <input class="w-full border border-gray-300 rounded px-2 py-1.5 focus:outline-none focus:ring-2 focus:ring-green-200 contact-input" type="text" id="contactName" name="contactName" autocomplete="name" placeholder="Enter your full name" required>
        </div>
        <div>
          <label class="block font-medium mb-1 text-xs" for="contactEmail">Email Address</label>
          <input class="w-full border border-gray-300 rounded px-2 py-1.5 focus:outline-none focus:ring-2 focus:ring-green-200 contact-input" type="email" id="contactEmail" name="contactEmail" autocomplete="email" placeholder="Enter your email address" required>
        </div>
        <div>
          <label class="block font-medium mb-1 text-xs" for="contactPhone">Phone Number</label>
          <input class="w-full border border-gray-300 rounded px-2 py-1.5 focus:outline-none focus:ring-2 focus:ring-green-200 contact-input" type="tel" id="contactPhone" name="contactPhone" inputmode="tel" autocomplete="tel" placeholder="Enter your phone number" required>
        </div>
        <p id="contactError" class="hidden text-center text-red-500 font-semibold mt-1 text-xs"></p>
      </div>
    </div>
  `;

  // Setup contact form fields and restore from sessionStorage
  const nameField = document.getElementById('contactName');
  const emailField = document.getElementById('contactEmail');
  const phoneField = document.getElementById('contactPhone');
  
  const setupAndRestore = (field, key) => {
      field.addEventListener('input', () => sessionStorage.setItem(key, field.value));
      const savedValue = sessionStorage.getItem(key);
      if (savedValue) field.value = savedValue;
  };
  setupAndRestore(nameField, 'contactName');
  setupAndRestore(emailField, 'contactEmail');
  setupAndRestore(phoneField, 'contactPhone');
  
  // Add real-time email validation
  emailField.addEventListener('input', () => {
    const contactErrorEl = document.getElementById('contactError');
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    
    if (emailField.value && !emailRegex.test(emailField.value)) {
      emailField.classList.add('error');
    } else {
      emailField.classList.remove('error');
      emailField.style.borderColor = ''; // Reset inline styles
      if (contactErrorEl && contactErrorEl.textContent.includes('valid email address')) {
        contactErrorEl.classList.add('hidden');
      }
    }
  });

  // Add visual feedback for keyboard navigation
  const addFieldFeedback = (field, isLast = false) => {
    field.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        // Add brief visual feedback
        const originalBorder = field.style.border;
        field.style.border = '2px solid #22c55e';
        field.style.transition = 'border-color 0.2s ease';
        
        setTimeout(() => {
          field.style.border = originalBorder;
        }, 200);
      }
    });
  };

  addFieldFeedback(nameField);
  addFieldFeedback(emailField);
  addFieldFeedback(phoneField, true); // Last field

  // Add keyboard navigation for contact form fields - Keep keyboard open
  nameField.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      
      // Move to next field without closing keyboard
      emailField.focus();
      emailField.setSelectionRange(emailField.value.length, emailField.value.length);
    }
  });

  emailField.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      
      // Move to next field without closing keyboard
      phoneField.focus();
      phoneField.setSelectionRange(phoneField.value.length, phoneField.value.length);
    }
  });

  phoneField.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      
      // On the last field, submit the form
      handleContactSubmission();
    }
  });

  // Auto-focus the name field
  setTimeout(() => {
    nameField.focus();
  }, 100);
  
  // Add a subtle indicator that refresh is disabled
  if (quizCard) {
    const refreshIndicator = document.createElement('div');
    refreshIndicator.className = 'fixed top-2 left-1/2 transform -translate-x-1/2 bg-yellow-100 border border-yellow-300 text-yellow-800 text-xs px-2 py-1 rounded-full z-50 opacity-75';
    refreshIndicator.textContent = '🔄 Refresh disabled during quiz';
    document.body.appendChild(refreshIndicator);
    
    // Remove indicator after 3 seconds
    setTimeout(() => {
      refreshIndicator.style.opacity = '0';
      setTimeout(() => {
        if (refreshIndicator.parentNode) {
          refreshIndicator.parentNode.removeChild(refreshIndicator);
        }
      }, 500);
    }, 3000);
  }

  // Immediately set the button to its final state for checkout
const buttonContainer = document.getElementById('buttonContainer');
buttonContainer.style.display = 'flex';
buttonContainer.classList.remove('hidden');

prevBtn.classList.remove('hidden'); // Show previous button
submitBtn.classList.remove('hidden');
submitButton.textContent = 'Buy Now';
submitButton.disabled = false;
submitButton.style.display = 'inline-block';
  
  // Remove old delegated handlers and bind directly to the button
  submitBtn.replaceWith(submitBtn.cloneNode(true));
  const buyNowBtn = document.getElementById('submitBtn');
  buyNowBtn.type = 'button';
  buyNowBtn.disabled = false;
  buyNowBtn.addEventListener('click', handleContactSubmission, {passive: false});
  buyNowBtn.addEventListener('pointerup', handleContactSubmission, {passive: false});
  
  // Add debugging to ensure button is properly set up
  console.log('Button setup - Text:', buyNowBtn.textContent, 'Disabled:', buyNowBtn.disabled, 'Display:', buyNowBtn.style.display);
  console.log('Button container display:', buttonContainer.style.display);
  
  // Update button position for checkout mode
  if (window.updateButtonPosition) {
    setTimeout(() => {
      window.updateButtonPosition();
    }, 100); // Small delay to ensure DOM is updated
  }
  
  // Button is now directly bound with event listeners - no additional setup needed
  
  // --- Background Submission ---
  Object.entries(answers).forEach(([k,v])=>{
    const hidden=document.createElement('input');
    hidden.type='hidden';hidden.name=k;hidden.value=(typeof v==='boolean'?v?1:'':v);
    quizForm.appendChild(hidden);
  });
  const blendNameForSubmission = answers.blendName || '';
  const fd=new FormData(quizForm);
  fd.set('userId',userId);
  fd.set('blendName', blendNameForSubmission);

  // Run submission in the background without affecting the UI
  submitToSheet(TAB_FORM, fd).then(res => {
      if (res.status !== 'OK') {
        // Log the error. A non-blocking UI element could be used here.
        console.error('Quiz submission failed:', res);
      } else {
        console.log('Quiz data saved in the background.');
      }
    })
    .catch(error => {
      console.error('Quiz submission network error:', error);
    });
}

async function handleQuizSubmission() {
  // This function handles the original quiz submission logic
  // Currently not used in the new flow, but kept for compatibility
}

function handleContactSubmission() {
  console.log('handleContactSubmission called');
  
  // Track checkout submit
  trackGA4('checkout_submit', { 
    blendName: answers.blendName || 'Custom Blend',
    budget: answers.priceRange,
    cupsPerDay: answers.cupsPerDay,
    roastLevel: answers.roastLevel,
    brewMethod: answers.brewMethod
  });
  
  // Check if button is properly set up
  const submitBtn = document.getElementById('submitBtn');
  console.log('Submit button state - Text:', submitBtn?.textContent, 'Disabled:', submitBtn?.disabled, 'Display:', submitBtn?.style.display);
  
  const nameField = document.getElementById('contactName');
  const emailField = document.getElementById('contactEmail');
  const phoneField = document.getElementById('contactPhone');
  const contactErrorEl = document.getElementById('contactError');
  
  console.log('Form fields found:', { nameField: !!nameField, emailField: !!emailField, phoneField: !!phoneField });
  
  if (!nameField || !emailField || !phoneField) {
    console.error('Contact form fields not found');
    return;
  }
      
      if (!nameField.value || !emailField.value || !phoneField.value) {
        contactErrorEl.classList.remove('hidden');
        return;
      }
      
      // Validate email format
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(emailField.value)) {
        contactErrorEl.textContent = 'Please enter a valid email address (e.g., name@example.com).';
        contactErrorEl.classList.remove('hidden');
        emailField.classList.add('error');
        emailField.focus();
        return;
      }
      
      // Clear any error states if validation passes
      contactErrorEl.classList.add('hidden');
      emailField.classList.remove('error');
      emailField.style.borderColor = ''; // Reset any inline styles

  // --- Background Submission ---
      const contactFD = new FormData();
      contactFD.set('formType', 'contact');
      contactFD.set('userId', userId);
      contactFD.set('contactName', nameField.value);
      contactFD.set('contactEmail', emailField.value);
      contactFD.set('contactPhone', phoneField.value);
  contactFD.set('blendName', answers.blendName || '');

  submitToSheet(TAB_CONTACT, contactFD)
    .then(res => {
      if (res.status !== 'OK') {
        console.error('Contact submission failed in background:', res);
        // Track submission failure
        trackGA4('submission_fail', { 
          step: 'contact', 
          error: res.status || 'unknown_error',
          blendName: answers.blendName || 'Custom Blend'
        });
      } else {
        console.log('Contact info submitted successfully in background.');
        // Track successful submission
        trackGA4('submission_ok', { 
          blendName: answers.blendName || 'Custom Blend',
          budget: answers.priceRange,
          cupsPerDay: answers.cupsPerDay
        });
      }
    })
    .catch(error => {
        console.error('Contact submission network error in background:', error);
        // Track submission failure
        trackGA4('submission_fail', { 
          step: 'contact', 
          error: error.message || 'network_error',
          blendName: answers.blendName || 'Custom Blend'
        });
    });

  // --- Immediate UI Transition ---
  document.getElementById('buttonContainer').classList.add('hidden');
  
        quizCard.innerHTML = `
          <div class="w-full max-w-md mx-auto">
            <div class="question-body">
              <div class="text-center py-10">
                <svg class="w-16 h-16 text-green-500 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                <h3 class="text-2xl font-bold text-gray-800">Thank you!</h3>
          <p class="text-gray-600 mt-2">Our roasters are still heating up. We are accepting beta testers at this time and will reach out to you to see if you would be interested in joining.</p>
              </div>
            </div>
          </div>
        `;
  
        sessionStorage.removeItem('userId');
  sessionStorage.removeItem('contactName');
  sessionStorage.removeItem('contactEmail');
  sessionStorage.removeItem('contactPhone');

  // Gracefully close the form after 4 seconds
  setTimeout(() => {
    const quizSection = document.getElementById('quiz');
    quizSection.classList.add('fullscreen-fade-out');
    
    setTimeout(() => {
      document.body.classList.remove('quiz-fullscreen');
      quizSection.classList.remove('quiz-fullscreen');
      document.getElementById('quizEscape').classList.add('hidden');
      quizSection.classList.remove('fullscreen-fade-out');
      document.getElementById('quiz').scrollIntoView({ behavior: 'smooth' });
    }, 800); // Fade out animation duration
  }, 4000); // 4 second delay
}

// Form submit event listener removed - now using button click handler instead

/* CONTACT SUBMIT - Now handled inline within quiz submission flow */
</script>
<script>
/* --- SAFETY GUARD: prevent premature submit -------------------------------- */
(function () {
  /* 1. Ensure navigation buttons are not accidental submits */
  ['nextBtn', 'prevBtn'].forEach(id => {
    const btn = document.getElementById(id);
    if (btn && btn.type !== 'button') btn.type = 'button';
  });

  /* 2. Block the ENTER key from submitting while quiz is in progress */
  const qForm = document.getElementById('quizForm');
  if (qForm) qForm.addEventListener('keydown', e => {
    if (e.key === 'Enter') e.preventDefault();
  });
})();

/* --- PREVENT REFRESH: disable page refresh during quiz/form fullscreen mode ----- */
(function () {
  document.addEventListener('keydown', e => {
    // Check if quiz or form is in fullscreen mode
    const isFullscreenMode = document.body.classList.contains('quiz-fullscreen');
    
    if (isFullscreenMode) {
      // Prevent F5
      if (e.key === 'F5') {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
      
      // Prevent Ctrl+R / Cmd+R (refresh)
      if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
      
      // Prevent Ctrl+F5 / Cmd+F5 (hard refresh)
      if ((e.ctrlKey || e.metaKey) && e.key === 'F5') {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
      
      // Prevent Ctrl+Shift+R / Cmd+Shift+R (hard refresh)
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'R') {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    }
  });
  
  // Also prevent beforeunload event during quiz or form interaction
  window.addEventListener('beforeunload', e => {
    const isFullscreenMode = document.body.classList.contains('quiz-fullscreen');
    
    if (isFullscreenMode) {
      // Show confirmation dialog for accidental navigation
      e.preventDefault();
      e.returnValue = 'Are you sure you want to leave? Your progress will be lost.';
      return e.returnValue;
    }
  });
  
  // Prevent mobile pull-to-refresh gesture (improved to not interfere with sliders)
  let touchStartY = 0;
  let isTrackingRefresh = false;
  
  document.addEventListener('touchstart', e => {
    const isFullscreenMode = document.body.classList.contains('quiz-fullscreen');
    if (isFullscreenMode) {
      // Only track for refresh prevention if not touching interactive elements
      const target = e.target;
      if (target && !target.closest('input[type="range"], button, .suggestion-chip')) {
        touchStartY = e.touches[0].clientY;
        isTrackingRefresh = true;
      }
    }
  }, { passive: true });
  
  document.addEventListener('touchmove', e => {
    const isFullscreenMode = document.body.classList.contains('quiz-fullscreen');
    if (isFullscreenMode && isTrackingRefresh) {
      const touchY = e.touches[0].clientY;
      const touchDiff = touchY - touchStartY;
      
      // Only prevent pull-to-refresh if scrolling down from the very top
      // Allow normal scrolling in all other cases
      if (touchDiff > 50 && window.scrollY === 0) {
        e.preventDefault();
      }
    }
  }, { passive: false });
  
  document.addEventListener('touchend', () => {
    isTrackingRefresh = false;
  }, { passive: true });
})();

/* --- BACK BUTTON NAVIGATION: use back button for previous question --------- */
(function () {
  let quizHistoryState = null;
  
  // Initialize history state when quiz starts
  function initQuizHistory() {
    const isQuizFullscreen = document.body.classList.contains('quiz-fullscreen');
    
    if (isQuizFullscreen && !quizHistoryState) {
      // Push a state for the quiz
      quizHistoryState = { quizActive: true, question: current };
      history.pushState(quizHistoryState, '', window.location.href);
    }
  }
  
  // Update history when question changes
  function updateQuizHistory(questionIndex) {
    const isQuizFullscreen = document.body.classList.contains('quiz-fullscreen');
    
    if (isQuizFullscreen) {
      quizHistoryState = { quizActive: true, question: questionIndex };
      history.replaceState(quizHistoryState, '', window.location.href);
    }
  }
  
  // Handle back button presses
  window.addEventListener('popstate', e => {
    const isQuizFullscreen = document.body.classList.contains('quiz-fullscreen');
    
    if (isQuizFullscreen) {
      // Prevent default back navigation
      e.preventDefault();
      
      // Navigate to previous question instead
      if (current > 0) {
        // Remove fade out animation if going back from last question
        if (current === quizData.length - 1) {
          const progressBar = document.getElementById('progressBar');
          const progressContainer = progressBar.parentElement;
          progressContainer.classList.remove('progress-fade-out');
        }
        current--;
        updateUI();
        updateQuizHistory(current);
      } else {
        // If at first question, ask if they want to exit
        if (confirm('Are you sure you want to exit the quiz? Your progress will be lost.')) {
          // Reset quiz and exit fullscreen
          current = 0;
          answers = {...defaults};
          document.body.classList.remove('quiz-fullscreen');
          document.getElementById('quiz').classList.remove('quiz-fullscreen');
          document.getElementById('quizEscape').classList.add('hidden');
          updateUI();
          quizHistoryState = null;
        } else {
          // Stay in quiz, push state back
          history.pushState(quizHistoryState, '', window.location.href);
        }
      }
    }
  });
  
  // Hook into autoNext to initialize history when quiz starts
  const originalAutoNext = window.autoNext;
  window.autoNext = function() {
    const wasAtStart = (current === 0);
    originalAutoNext();
    
    // Initialize history when quiz first goes fullscreen
    if (wasAtStart && current === 1) {
      setTimeout(initQuizHistory, 50); // Small delay to ensure fullscreen class is set
    }
  };
  
  // Hook into updateUI to update history
  const originalUpdateUI = window.updateUI;
  window.updateUI = function() {
    originalUpdateUI();
    updateQuizHistory(current);
  };
  
  // Reset history state when quiz exits
  const originalQuizEscape = document.getElementById('quizEscape');
  if (originalQuizEscape) {
    originalQuizEscape.addEventListener('click', () => {
      quizHistoryState = null;
    });
  }
})();



// Login Modal Functionality
document.addEventListener('DOMContentLoaded', function() {
  const loginBtn = document.getElementById('loginBtn');
  const loginModal = document.getElementById('loginModal');
  const closeLoginModal = document.getElementById('closeLoginModal');
  const loginForm = document.getElementById('loginForm');
  const loginError = document.getElementById('loginError');

  // Open modal
  loginBtn.addEventListener('click', function(e) {
    e.preventDefault();
    loginModal.classList.remove('hidden');
    document.body.style.overflow = 'hidden';
  });

  // Close modal
  closeLoginModal.addEventListener('click', function() {
    loginModal.classList.add('hidden');
    document.body.style.overflow = 'auto';
    loginError.classList.add('hidden');
    loginForm.reset();
  });

  // Close modal when clicking outside
  loginModal.addEventListener('click', function(e) {
    if (e.target === loginModal) {
      loginModal.classList.add('hidden');
      document.body.style.overflow = 'auto';
      loginError.classList.add('hidden');
      loginForm.reset();
    }
  });

  // Handle form submission
  loginForm.addEventListener('submit', function(e) {
    e.preventDefault();
    
    // Always show "User not found" error
    loginError.classList.remove('hidden');
    
    // Add a small delay to simulate processing
    setTimeout(() => {
      loginError.classList.remove('hidden');
    }, 500);
  });

  // Close modal with Escape key
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && !loginModal.classList.contains('hidden')) {
      loginModal.classList.add('hidden');
      document.body.style.overflow = 'auto';
      loginError.classList.add('hidden');
      loginForm.reset();
    }
  });
});
</script>

<script>
  /* ——— Surgical patch: Mobile Safari blend page protection ——— */
  function tryOrFallback(fn, fallbackHTML = '') {
    try { return fn(); }
    catch (err) {
      console.warn('[Blend page] fell back:', err);
      return fallbackHTML;
    }
  }

  /* ——— Mobile-first refactor JavaScript ——— */
/* Dynamic vh unit - only update on orientation change, not keyboard events */
let lastVH = window.innerHeight;
function setVhOncePerOrientation () {
  const now = window.innerHeight;
  /* ignore keyboard deltas (< 160 px), react only to rotation */
  if (Math.abs(now - lastVH) > 200){
    document.documentElement.style.setProperty('--vh', `${now * .01}px`);
    lastVH = now;
  }
}
window.addEventListener('resize', setVhOncePerOrientation, {passive:true});

/* IMPROVED: Keep navigation bar stable during keyboard events */
(function () {
  const nav = document.getElementById('buttonContainer');
  if (!nav) return;

  let keyboardState = 'closed'; // 'closed', 'opening', 'open', 'closing'
  let lastKeyboardHeight = 0;
  let stableKeyboardHeight = 0;
  let keyboardStateTimeout;
  let isUpdating = false;
  
  // Add smooth transition for button movement
  nav.style.transition = 'bottom 0.3s cubic-bezier(0.4, 0, 0.2, 1)';

  const updateButtonPosition = (forced = false) => {
    if (isUpdating && !forced) return;
    
    // QUIZ MODE: Don't move buttons during quiz - keep them stable
    const isQuizMode = document.body.classList.contains('quiz-active') || 
                      document.body.classList.contains('quiz-fullscreen');
    
    if (isQuizMode) {
      nav.style.position = 'fixed';
      nav.style.left = '50%';
      nav.style.transform = 'translateX(-50%)';
      nav.style.bottom = 'calc(env(safe-area-inset-bottom, 0px) + 1rem)';
      nav.style.transition = 'none'; // No movement during quiz
      console.log('Quiz mode: Buttons locked in stable position');
      return;
    }
    
    // Desktop mode (≥640px) - use consistent fixed positioning
    if (window.innerWidth >= 640) {
      nav.style.position = 'fixed';
      nav.style.bottom = '2rem';  // UPDATED: matches CSS for compact layout
      nav.style.left = '50%';
      nav.style.transform = 'translateX(-50%)';
      console.log('Desktop mode - using compact fixed positioning');
      return;
    }
    
    if (window.visualViewport) {
      const visualViewportHeight = window.visualViewport.height;
      const visualViewportTop = window.visualViewport.offsetTop;
      const keyboardHeight = Math.max(0, window.innerHeight - visualViewportHeight - visualViewportTop);
      
      // Check if we're in checkout mode
      const submitBtn = document.getElementById('submitBtn');
      const isCheckoutMode = submitBtn && submitBtn.textContent.trim() === 'Buy Now';
      
      // More sophisticated keyboard state detection
      const heightDelta = Math.abs(keyboardHeight - lastKeyboardHeight);
      
      // Only react to significant changes (> 30px) to prevent micro-adjustments
      if (heightDelta < 30 && !forced) {
        return;
      }
      
      // Determine keyboard state with hysteresis
      let newState = keyboardState;
      if (keyboardHeight > 200) {
        newState = 'open';
        stableKeyboardHeight = keyboardHeight;
      } else if (keyboardHeight < 100) {
        newState = 'closed';
        stableKeyboardHeight = 0;
      }
      
      // Only update position if state changed or forced
      if (newState !== keyboardState || forced) {
        isUpdating = true;
        keyboardState = newState;
        lastKeyboardHeight = keyboardHeight;
        
        // Clear any pending state changes
        clearTimeout(keyboardStateTimeout);
        
        // Reset to mobile fixed positioning
        nav.style.position = 'fixed';
        nav.style.left = '50%';
        nav.style.transform = 'translateX(-50%)';
        
        if (keyboardState === 'open') {
          // Position button above keyboard with buffer
          const buttonOffset = isCheckoutMode ? 2 : 1.5;
          nav.style.bottom = `${stableKeyboardHeight + buttonOffset}rem`;
          console.log(`Mobile keyboard open - Button positioned above keyboard: ${stableKeyboardHeight + buttonOffset}rem`);
        } else {
          // Return to normal position
          const normalOffset = isCheckoutMode ? 1.5 : 1;
          nav.style.bottom = `calc(var(--safe-bottom) + ${normalOffset}rem)`;
          console.log(`Mobile keyboard closed - Button returned to normal position: ${normalOffset}rem`);
        }
        
        // Reset updating flag after transition
        setTimeout(() => {
          isUpdating = false;
        }, 300);
      }
    } else {
      // Fallback for mobile browsers without visualViewport
      const submitBtn = document.getElementById('submitBtn');
      const isCheckoutMode = submitBtn && submitBtn.textContent.trim() === 'Buy Now';
      const normalOffset = isCheckoutMode ? 1.5 : 1;
      
      nav.style.position = 'fixed';
      nav.style.left = '50%';
      nav.style.transform = 'translateX(-50%)';
      nav.style.bottom = `calc(var(--safe-bottom) + ${normalOffset}rem)`;
    }
  };

  // Debounced update with longer delay to prevent rapid changes
  let updateTimeout;
  const debouncedUpdate = () => {
    clearTimeout(updateTimeout);
    updateTimeout = setTimeout(() => updateButtonPosition(), 150);
  };

  // Listen for viewport changes with more conservative throttling
  if (window.visualViewport) {
    let lastUpdateTime = 0;
    const throttledUpdate = () => {
      const now = Date.now();
      if (now - lastUpdateTime > 150) { // Longer throttle period
        lastUpdateTime = now;
        debouncedUpdate();
      }
    };
    
    window.visualViewport.addEventListener('resize', throttledUpdate);
    window.visualViewport.addEventListener('scroll', throttledUpdate);
  }
  
  // Initial position
  updateButtonPosition(true);
  
  // Export function for manual updates
  window.updateButtonPosition = () => updateButtonPosition(true);
  
  // Handle desktop/mobile transitions on window resize
  window.addEventListener('resize', () => {
    clearTimeout(updateTimeout);
    updateTimeout = setTimeout(() => updateButtonPosition(true), 150);
  });
  
  // Force update when text inputs get focus/blur
  document.addEventListener('focusin', (e) => {
    if (e.target.matches('input[type="text"], input[type="email"], input[type="tel"], textarea')) {
      setTimeout(() => updateButtonPosition(true), 300);
    }
  });
  
  document.addEventListener('focusout', (e) => {
    if (e.target.matches('input[type="text"], input[type="email"], input[type="tel"], textarea')) {
      setTimeout(() => updateButtonPosition(true), 300);
    }
  });
})();

/* IMPROVED: Toggle keyboard-open class with better stability */
(function(){
  let lastKeyboardState = false;
  let toggleTimeout;
  let stateChangeCount = 0;
  
  const toggle = () => {
    if (window.visualViewport) {
      const visualViewportHeight = window.visualViewport.height;
      const visualViewportTop = window.visualViewport.offsetTop;
      const keyboardHeight = Math.max(0, window.innerHeight - visualViewportHeight - visualViewportTop);
      
      // Higher threshold and more stable detection
      const open = keyboardHeight > 200; // Increased threshold to 200px
      
      // Only toggle if state actually changed
      if (open !== lastKeyboardState) {
        stateChangeCount++;
        
        // Clear any pending toggle
        clearTimeout(toggleTimeout);
        
        // Longer delay for stability, but immediate visual feedback
        toggleTimeout = setTimeout(() => {
          lastKeyboardState = open;
          document.body.classList.toggle('keyboard-open', open);
          console.log(`Keyboard state changed: ${open ? 'OPEN' : 'CLOSED'} (height: ${keyboardHeight}px)`);
        }, 400); // Longer delay for more stability
      }
    }
  };
  
  if (window.visualViewport) {
    // Use more conservative throttling
    let lastToggleTime = 0;
    const throttledToggle = () => {
      const now = Date.now();
      if (now - lastToggleTime > 200) {
        lastToggleTime = now;
        toggle();
      }
    };
    
    window.visualViewport.addEventListener('resize', throttledToggle);
    window.visualViewport.addEventListener('scroll', throttledToggle);
  }
  
  // Initial state
  toggle();
})();

/* Focus handler: centre the element inside the scrolling card */
document.addEventListener('focusin', e => {
  if (e.target.matches('input, textarea')){
    e.target.scrollIntoView({block:'center', behavior:'smooth'});
  }
});

/* Prevent accidental refresh during quiz */
(function() {
  let isQuizActive = false;
  
  // Apply initial protection when page loads
  document.addEventListener('DOMContentLoaded', function() {
    // If quiz is visible on page load, apply protection immediately
    const quizSection = document.getElementById('quiz');
    if (quizSection && window.getComputedStyle(quizSection).display !== 'none') {
      document.body.classList.add('quiz-active');
      isQuizActive = true;
    }
  });
  
  // Track quiz state
  const originalUpdateUI = updateUI;
  updateUI = function() {
    originalUpdateUI.apply(this, arguments);
    
    // Check if quiz is active (starts immediately when quiz is visible)
    isQuizActive = current >= 0; // Changed from > 0 to >= 0 to include first question
    
    // Update body class for CSS targeting - always add when quiz is shown
    if (isQuizActive && current >= 0) {
      document.body.classList.add('quiz-active');
    } else {
      document.body.classList.remove('quiz-active');
    }
  };
  
  // Prevent beforeunload (refresh/close) during active quiz
  window.addEventListener('beforeunload', (e) => {
    if (isQuizActive) {
      e.preventDefault();
      e.returnValue = 'You have unsaved quiz progress. Are you sure you want to leave?';
      return e.returnValue;
    }
  });
  
  // UNIVERSAL pull-to-refresh prevention for all mobile browsers
  let touchStartY = 0;
  let touchStartX = 0;
  let isAtPageTop = false;
  let preventRefresh = false;
  
  // Detect browser type for specific handling
  const isChrome = /Chrome/i.test(navigator.userAgent);
  const isFirefox = /Firefox/i.test(navigator.userAgent);
  const isSamsung = /SamsungBrowser/i.test(navigator.userAgent);
  const isEdge = /Edge/i.test(navigator.userAgent);
  
  document.addEventListener('touchstart', (e) => {
    if (document.body.classList.contains('quiz-active') || document.body.classList.contains('quiz-fullscreen')) {
      touchStartY = e.touches[0].clientY;
      touchStartX = e.touches[0].clientX;
      isAtPageTop = window.scrollY <= 10; // More generous top detection
      preventRefresh = false;
    }
  }, { passive: true });
  
  document.addEventListener('touchmove', (e) => {
    if (document.body.classList.contains('quiz-active') || document.body.classList.contains('quiz-fullscreen')) {
      const currentY = e.touches[0].clientY;
      const currentX = e.touches[0].clientX;
      const deltaY = currentY - touchStartY;
      const deltaX = currentX - touchStartX;
      
      // Check if touch is happening within quiz content that should scroll normally
      const quizCard = document.getElementById('quizCard');
      const quizForm = document.getElementById('quizForm');
      const target = e.target;
      
      const isInQuizContent = (quizCard && quizCard.contains(target)) || 
                              (quizForm && quizForm.contains(target)) ||
                              target.closest('.custom-roast-content') ||
                              target.closest('#quizCard') ||
                              target.closest('#quizForm');
      
      // Check if this is a vertical downward gesture
      const isVerticalPull = Math.abs(deltaY) > Math.abs(deltaX);
      const isPullingDown = deltaY > 0;
      
      // Only prevent if NOT scrolling within quiz content
      if (!isInQuizContent && isAtPageTop && isPullingDown && isVerticalPull) {
        // Very aggressive thresholds for all browsers
        let threshold = 1; // Default threshold - very sensitive
        if (isChrome) threshold = 1; // Chrome - immediate prevention
        if (isFirefox) threshold = 2; // Firefox 
        if (isSamsung) threshold = 1; // Samsung browser
        if (isEdge) threshold = 1; // Edge browser
        
        if (deltaY > threshold && window.scrollY <= 10) {
          preventRefresh = true;
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
          return false;
        }
      }
      
      // Continue preventing if we've started (but only for non-quiz content)
      if (preventRefresh && !isInQuizContent) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    }
  }, { passive: false });
  
  document.addEventListener('touchend', (e) => {
    if (document.body.classList.contains('quiz-active') || document.body.classList.contains('quiz-fullscreen')) {
      // Reset prevention state
      preventRefresh = false;
      touchStartY = 0;
      touchStartX = 0;
      isAtPageTop = false;
    }
  }, { passive: true });
  
  // Universal overscroll prevention
  if ('overscroll' in window) {
    document.addEventListener('overscroll', (e) => {
      if (document.body.classList.contains('quiz-active') || document.body.classList.contains('quiz-fullscreen')) {
        e.preventDefault();
        return false;
      }
    }, { passive: false });
  }
  
  // Prevent negative scroll positions (universal)
  let lastScrollY = 0;
  window.addEventListener('scroll', (e) => {
    if (document.body.classList.contains('quiz-active') || document.body.classList.contains('quiz-fullscreen')) {
      const currentScrollY = window.scrollY;
      
      // Prevent negative scroll
      if (currentScrollY < 0) {
        window.scrollTo(0, 0);
        e.preventDefault();
        return false;
      }
      
      // Prevent bounce-back to refresh on some Android browsers
      if (currentScrollY < lastScrollY && currentScrollY <= 5) {
        if (Math.abs(currentScrollY - lastScrollY) > 50) {
          window.scrollTo(0, Math.max(0, lastScrollY));
          e.preventDefault();
          return false;
        }
      }
      
      lastScrollY = currentScrollY;
    }
  }, { passive: false });
  
  // Additional prevention for Chrome's pull-to-refresh
  if (isChrome) {
    document.addEventListener('scroll', (e) => {
      if (document.body.classList.contains('quiz-active') || document.body.classList.contains('quiz-fullscreen')) {
        if (window.scrollY === 0) {
          // Force a tiny scroll to prevent Chrome's pull-to-refresh
          setTimeout(() => {
            if (window.scrollY === 0) {
              window.scrollTo(0, 1);
              setTimeout(() => window.scrollTo(0, 0), 1);
            }
          }, 1);
        }
      }
    }, { passive: true });
  }
  
  // EXTRA AGGRESSIVE: Prevent any touch that starts at the very top edge
  document.addEventListener('touchstart', (e) => {
    if (document.body.classList.contains('quiz-active') || document.body.classList.contains('quiz-fullscreen')) {
      const touch = e.touches[0];
      const isAtTopEdge = touch.clientY < 50; // Top 50px of screen
      const isAtPageTop = window.scrollY <= 5;
      
      // Check if touch is NOT in quiz content
      const target = e.target;
      const isInQuizContent = target.closest('#quizCard') || 
                              target.closest('#quizForm') || 
                              target.closest('.custom-roast-content');
      
      if (isAtTopEdge && isAtPageTop && !isInQuizContent) {
        // Immediately prevent any potential refresh gesture
        setTimeout(() => {
          if (window.scrollY <= 1) {
            preventRefresh = true;
          }
        }, 1);
      }
    }
  }, { passive: true });
})();

/* IMPROVED: Fallback keyboard detection for browsers without visualViewport */
(function() {
  if (window.visualViewport) return; // Skip if visualViewport is available
  
  let lastWindowHeight = window.innerHeight;
  let keyboardTimeout;
  let isKeyboardOpen = false;
  
  const handleResize = () => {
    const currentHeight = window.innerHeight;
    const heightDiff = lastWindowHeight - currentHeight;
    
    // Clear any pending timeout
    clearTimeout(keyboardTimeout);
    
    // Debounce the keyboard state change
    keyboardTimeout = setTimeout(() => {
      let shouldBeOpen = false;
      
      // If height decreased significantly, keyboard is likely open
      if (heightDiff > 200) { // Higher threshold for more reliability
        shouldBeOpen = true;
      } else if (heightDiff < -100) { // Keyboard closed
        shouldBeOpen = false;
      } else {
        // No significant change, keep current state
        return;
      }
      
      // Only update if state actually changed
      if (shouldBeOpen !== isKeyboardOpen) {
        isKeyboardOpen = shouldBeOpen;
        document.body.classList.toggle('keyboard-open', isKeyboardOpen);
        console.log(`Fallback keyboard detection: ${isKeyboardOpen ? 'OPEN' : 'CLOSED'} (height change: ${heightDiff}px)`);
        
        // Update button position
        if (window.updateButtonPosition) {
          window.updateButtonPosition();
        }
      }
      
      lastWindowHeight = currentHeight;
    }, 300); // Debounce for stability
  };
  
  window.addEventListener('resize', handleResize);
})();

/* ——— make sure the newly rendered question is scrolled into view ——— */
function renderQuestionMobileScrollGuard () {
  const card = document.getElementById('quizCard');
  if(card) card.scrollTop = 0;      /* jump to top                       */
  /* optionally focus the first interactive element (already in your code) */
}

/* hook it into your existing updateUI() / renderQuestion() cycle */
const _renderQuestion = renderQuestion;      // keep the original
renderQuestion = (idx) => {                  // override
  _renderQuestion(idx);
  renderQuestionMobileScrollGuard();
};
</script>

<script>
/* augment the existing scroll‑guard */
function renderQuestionDesktopScrollGuard(){
  if (window.innerWidth >= 640){
    const card = document.getElementById('quizCard');
    if(card) card.scrollTop = 0;
  }
}
const _renderQuestionStable = renderQuestion;          // keep last override
renderQuestion = (idx)=>{
  _renderQuestionStable(idx);                           // draw question
  renderQuestionDesktopScrollGuard();                   // then align frame
};
</script>
<script>
/* ------------------------------------------------------------------
   UNIVERSAL “NO-REFRESH-WHILE-QUIZ” GUARD
   Activates whenever <body> has class "quiz-fullscreen"
------------------------------------------------------------------ */
(function () {
  const BODY   = document.body;
  let quizActive = false;
  let isP2RBlocked = false;

  // 1. Desktop keyboard shortcuts (F5 / Ctrl/⌘+R)
  document.addEventListener('keydown', e => {
    if (!quizActive) return;
    const k = e.key.toLowerCase();
    const meta = e.metaKey || e.ctrlKey;
    const hard = (meta && e.shiftKey && k === 'r') || (meta && k === 'f5');
    if (k === 'f5' || (meta && k === 'r') || hard) {
      e.preventDefault();
      e.stopPropagation();
    }
  });

  // 2. beforeunload confirmation (all platforms)
  window.addEventListener('beforeunload', e => {
    if (!quizActive) return;
    e.preventDefault();
    e.returnValue = '';
    return '';
  });

  // 3. Mobile pull-to-refresh / bounce blocker
  let startY = 0;
  document.addEventListener('touchstart', e => {
    if (!quizActive) return;
    startY = e.touches[0].clientY;
    isP2RBlocked = (window.scrollY <= 0 && startY < 60);
  }, {passive:true});

  document.addEventListener('touchmove', e => {
    if (!quizActive || !isP2RBlocked) return;
    const dy = e.touches[0].clientY - startY;
    if (dy > 0) {      // downward gesture
      e.preventDefault();
      e.stopPropagation();
    }
  }, {passive:false});
  document.addEventListener('touchend',()=>{isP2RBlocked=false},{passive:true});

  // 4. Watch for class toggle
  const ob = new MutationObserver(()=>{
    const active = BODY.classList.contains('quiz-fullscreen');
    if(active!==quizActive){
      quizActive=active;
      BODY.style.overscrollBehaviorY = quizActive? 'none':'';
    }
  });
  ob.observe(BODY,{attributes:true,attributeFilter:['class']});
})();

// Track page view
trackGA4('page_view', {
  page_title: document.title,
  page_location: window.location.href,
  user_agent: navigator.userAgent
});
</script>
</body>
</html>
